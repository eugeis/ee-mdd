jpa.component.module.initializer = '''<% def className = "${component.names.initializer}" %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.annotation.PostConstruct;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.inject.Inject;

/** Initializer bean for '$component.name' */
@Singleton
@Startup
@SupportsEnvironments(@Environment(runtimes = { SERVER }))
public class $className extends ${className}Base {

  @Override
  @PostConstruct
  public void init() {
    try {
      super.init();
      // add additional startup tasks here
    } catch (Exception e) {
      log.error("$className failed", e);
    }
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %>'''

jpa.component.module.initializerBase = '''<% def className = "${component.names.initializer}Base"; boolean profile = component.hasProfiles() %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;
<% if (profile) { %>
import com.siemens.ra.cg.pl.common.profile.core.ProfileManager;
import com.siemens.ra.cg.pl.common.profile.integ.ejb.ProfileSchemaGenerator;
import ${shared.namespaces.integ}.${module.shared.names.constants}Base;
<% } %><% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
import ${destModule.namespaces.core}.${module.names.stateTimeoutHandler};<% } } %>

/** Initialiter for '$module.name' */
public class $className {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  <% if (profile) { %>
  private ProfileManager profileManager;
  private ProfileSchemaGenerator profileSchemaGenerator;
  <% } %><% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
  private $module.names.stateTimeoutHandler $module.names.stateTimeoutHandlerInstance;<% } } %><% if(module.entities) { %>
  protected ${module.capShortName}SchemaGenerator schemaGenerator;<% } %>

  public void init() {<% if (profile) { %>
    profileSchemaGenerator.createSchema();
    profileManager.importProfile(${module.shared.names.constants}Base.COMPONENT_PROFILE_FILENAME);<% } %><% if(module.entities) { %>
    schemaGenerator.createSchema();<% } %><% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
    ${module.names.stateTimeoutHandlerInstance}.registerTimer();<% } } %>
  }<% if(module.entities) { %>
  
  @Inject
  public void setSchemaGenerator(${module.capShortName}SchemaGenerator schemaGenerator) {
    this.schemaGenerator = schemaGenerator;
  }<% } %><% if (profile) { %>
  
  @Inject
  public void setProfileSchemaGenerator(ProfileSchemaGenerator profileSchemaGenerator) {
    this.profileSchemaGenerator = profileSchemaGenerator;
  }
  
  @Inject
  public void setProfileManager(ProfileManager profileManager) {
    this.profileManager = profileManager;
  }<% } %><% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
  
  @Inject
  public void set$module.names.stateTimeoutHandler($module.names.stateTimeoutHandler $module.names.stateTimeoutHandlerInstance) {
    this.$module.names.stateTimeoutHandlerInstance = $module.names.stateTimeoutHandlerInstance;
  }<% } } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %>'''

jpa.component.module.producerLocal = '''<% def className = "${component.capShortName}ProducerLocal" %>
$macros.header
package ${destModule.namespaces.integ}.jse;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import ${component.namespaces.integ}.$component.names.qualifier;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.ejb.locator.EntityManagerFactoryLocator;

/** CDI resources producer for '$module.name' in Local Mode*/
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { LOCAL }))
@Traceable
public class $className {
  private volatile static EntityManager entityManager;

  public static EntityManager entityManager() {
    if (entityManager == null) {
      EntityManagerFactory entityManagerFactory = EntityManagerFactoryLocator.
          findEntityManagerFactory(PERSISTENCE_UNIT_LOCAL, null, ${className}.class.getClassLoader());
      entityManager = entityManagerFactory.createEntityManager();
    }
    return entityManager;
  }

  @Produces
  @$component.names.qualifier
  public EntityManager getEntityManager() {
    return entityManager();
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/jse/${className}.java" %>'''

jpa.component.module.producerServer = '''<% if(component.facet('jpa') && module.entities) { %><% def className = "${component.capShortName}ProducerServer" %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${component.namespaces.integ}.$component.names.qualifier;

/** Server CDI resources producer for '$module.name' */
@Stateless
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }))
@Traceable
public class $className {

  @PersistenceContext(unitName = PERSISTENCE_UNIT)
  private EntityManager entityManager;

  @Produces
  @${component.names.qualifier}
  public EntityManager getEntityManager() {
    return entityManager;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.component.module.qualifier = '''<% def className = component.names.qualifier %>
$macros.header
package ${shared.namespaces.integ};

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import javax.inject.Qualifier;

import com.siemens.ra.cg.pl.common.base.cdi.DependsOnExecutionType;

/**
* The qualifier of '$module.name' what can be used in artifacts at dependency management and event messaging.
* The qualifier allows to select correct implementation of the common/generic interfaces.
*/
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.CONSTRUCTOR })
@DependsOnExecutionType
public @interface $className {
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/${className}.java" %>'''


common.backend.module.cache = '''<% if(module.containers.find { it.controller.cache }) { %><% def className = module.names.cache %>
$macros.header
package ${destModule.namespaces.core};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@ApplicationScoped
public class $className extends $module.names.cacheBase {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.module.cacheBase = '''<% if(module.containers.find { it.controller.cache }) { %><% def className = module.names.cacheBase %>
$macros.header
package ${destModule.namespaces.core};<% if(module.containers.find { it.controller.cache }) { %>

import ${destModule.namespaces.model}.*;<% } %>

public abstract class $className {<% module.containers.findAll { it.controller.cache }.each { container -> %>

  protected $container.names.clazz $container.names.instance;<% } %><% module.containers.findAll { it.controller.cache }.each { container -> %>

  public $container.names.clazz get$container.capName() {
    return $container.names.instance;
  }

  public void set$container.capName($container.names.clazz $container.names.instance) {
    this.$container.names.instance = $container.names.instance;
  }<% } %>

  public void clear() {<% module.containers.findAll { it.controller.cache }.each { container -> %>
    $container.names.instance = null;<% } %>
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>'''


common.all.module.cdiConfiguration = '''<% def className = "${module.names.classPrefix}CdiConfiguration" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.List;

/** Definition of CDI beans for '$module.name', in order to avoid scanning */
public class $className extends ${destModule.names.classPrefix}CdiConfigurationBase {
  @Override
  public List<Class<?>> getContainerClasses() {
    return super.getContainerClasses();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.all.module.cdiConfigurationTest = '''<% def className = "${module.names.classPrefix}CdiConfigurationTest" %>
$macros.header
package ${destModule.namespaces.integ};

import org.junit.Test;

public class $className {
  @Test
  public void testGetContainerClassesForNoExceptions() {
    ${module.names.classPrefix}CdiConfiguration cdiConfiguration = new ${module.names.classPrefix}CdiConfiguration();
    cdiConfiguration.getContainerClasses();
    //ok, no exceptions
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.all.module.cdiConfigurationForTestPackage = '''<% def className = "${destModule.names.classPrefix}TestCdiConfiguration" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.List;

/** Definition of CDI test beans for '$module.name', in order to avoid scanning */
public class $className extends ${module.names.classPrefix}TestCdiConfigurationBase {
  @Override
  public List<Class<?>> getContainerClasses() {
    return super.getContainerClasses();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.all.module.componentCdiBeansProperties = '''cdi.configuration.factory=${destModule.namespaces.integ}.${module.names.classPrefix}CdiConfiguration
<% ret.overwrite = false; ret.path = "${destModule.resSrc}/META-INF/beans.properties" %>'''

common.all.module.componentCdiBeansXml = '''<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>
<% ret.overwrite = false; ret.path = "${destModule.resSrc}/META-INF/beans.xml" %>'''

common.all.module.componentTestCdiBeansProperties = '''cdi.configuration.factory=${destModule.namespaces.integ}.${module.names.classPrefix}TestCdiConfiguration
<% ret.overwrite = false; ret.path = "${destModule.resTestSrc}/META-INF/beans.properties" %>'''

common.all.module.componentTestCdiBeansXml = '''<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>
<% ret.overwrite = false; ret.path = "${destModule.resTestSrc}/META-INF/beans.xml" %>'''

common.all.enums.enum_ = '''<% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.$item.namespace;<% if(item.finders) { %>

import static com.siemens.ra.cg.pl.common.base.util.ComparisonUtils.*;
import java.util.ArrayList;
import java.util.List;<% } %><% if(item.xmlBinding) { %>
import javax.xml.bind.annotation.XmlEnumValue;<% } %>
$item.imports

import java.util.List;
import java.util.Date;
import com.siemens.ra.cg.pl.common.base.exception.ControlguideNotFoundException;
import com.siemens.ra.cg.pl.common.base.ml.MLKey;
import com.siemens.ra.cg.pl.common.base.ml.MlKeyBuilder;
import com.siemens.ra.cg.pl.common.base.ml.MLKeyImpl;
import com.siemens.ra.cg.pl.common.base.model.Labeled;
import ${shared.namespaces.integ}.${shared.names.ml};

${item.description?"/*** $item.description */":''}
public enum $className implements Labeled, MlKeyBuilder { <% def first = true; item.literals.each { %><% if(first) { first = false } else { %>,<% } %><% if(it.description) { %>
  /** $it.description */<% } %><% if(item.xmlBinding) { %>
  @XmlEnumValue("$it.xmlValue")<% } %>
  $it.definition<% } %>;
  <% item.props.each { prop-> %>
  private $prop.computedType $prop.uncapName;<% } %>
  ${macros.apply(name: 'constructorsEnum', className: className)}<% item.props.each { prop-> %>

  public $prop.computedType $prop.getter {
    return $prop.name;
  }<% } %><% item.literals.each { literal-> %>

  public boolean is${literal.capName}() {
    return this == $literal.underscoredName;
  }<% } %><% item.operations.each { op-> if(op.body) { %>
  <% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } } %>

  @Override  
  public MLKey buildMlKey() {
    return new MLKeyImpl(${shared.names.ml}.ML_BASE, name());
  }

  @Override
  public String getNaturalKey() {
    $item.naturalKeyBody
  }

  public static $className findByOrdinal(int ordinal) {
    if (ordinal < values().length) {
      return values()[ordinal];
    } else {
      throw new ControlguideNotFoundException("$className(ordinal)", ordinal);
    }
  }

  public static $className findByName(String name, $className defaultValue) {
    $className ret = defaultValue;
    if (name != null) {
      for ($className literal : values()) {
        if (literal.name().equalsIgnoreCase(name)) {
          ret = literal;
          break;
        }
      }
    }
    return ret;
  }<% item.finders.each { op-> %>

  public static $op.returnTypeExternal ${op.name}($op.signature) {
    $op.returnTypeExternal ret = null;
    for ($className typeUnit : values()) {
      if (${op.propCompare}) {<% if(op.unique) { %>
        ret = typeUnit;
        break;<% } else { %>
        if(ret == null) {
          ret = new ArrayList<>();
        }
        ret.add(typeUnit);<% } %>
      }
    }<% if(op.mustFind || op.defaultValue) { %>
    if(ret == null) {<% if(op.defaultValue) { %>
      ret = $op.defaultValue;<% } else { %>
      throw new ControlguideNotFoundException("$className($op.signatureNames)", $op.signatureNames);<% } %>
    }<% } %>
    return ret;
  }<% } %>
}
<% ret.path = "${item.toShared ? destModule.shared.javaSrcGen : destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.client.module.cdiConfigurationBase = '''<% def className = "${module.names.classPrefix}CdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;

/** Definition of CDI beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();
    return ret;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''


common.client.module.cdiConfigurationTestBase = '''<% def className = "${module.names.classPrefix}TestCdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;

/** Definition of CDI test beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  
  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();
    return ret;
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.shared.module.cdiConfigurationBase = '''<% def className = "${module.names.classPrefix}CdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;<% module.dependModules.each { depModule -> if(depModule.configs) { %>
import ${depModule.namespaces.model}.*;<% } %><% if(depModule.type.backend) { %><% if(depModule.entities) { %>
import ${depModule.namespaces.model}.*;
import ${depModule.namespaces.model}.ejb.*;
import ${depModule.namespaces.model}.impl.*;
import ${depModule.namespaces.model}.ejb.builder.*;
import ${depModule.namespaces.integ}.*;
import ${depModule.namespaces.integ}.jse.*;<% } %><% if(depModule.services) { %>
import ${depModule.namespaces.facade}.*;
import ${depModule.namespaces.facade}.provider.*;
import ${depModule.namespaces.integ}.ejb.*;
import ${depModule.namespaces.integ}.jse.*;<% } %><% } %><% if(depModule.type.stateMachine) { %>
import ${depModule.namespaces.model}.meta.*;
import ${depModule.namespaces.model}.impl.*;<% if(depModule.conditions) { %>
import ${depModule.namespaces.model}.cond.impl.*;<% } %><% if(!depModule.entities && depModule.actions.find {it.async}) { %>
import ${depModule.namespaces.integ}.jse.*;
import ${depModule.namespaces.integ}.*;<% } %><% } %><% } %>

/** Definition of CDI beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();<% if(component.shared == module) { %>
    ret.add(${component.names.qualifier}.class);<% def modules = []; modules.addAll(component.backends.findAll { m -> m.entities } );  modules.addAll(component.stateMachines.findAll { m -> (m.type.stateMachine && m.actions.find {it.async} ) } ) %><% if(modules) { %>
    ret.add(${component.names.notificationPlugin}.class);<% } %><% if(component.facet('jpa') && component.name != 'Common') { %>
    ret.add(${component.capShortName}Producer.class);<% } } %><% module.dependModules.each { depModule -> if(depModule.type.backend) { %><% if(depModule.entities) { %><% if(depModule.facet('jpa')) { %>
    ret.add(${depModule.names.modelFactory}Ejb.class);<% } } %><% if(depModule.facet('entityImpl')) { %>
    ret.add(${depModule.names.modelFactory}Impl.class);<% } %><% if(component.facet('jpa')) { %><% [depModule.basicTypes, depModule.entities].each { it.each { t-> if(!t.virtual) { %>
    ret.add(${t.names.bean}Factory.class);<% } } } %><% } %><% if(depModule.entities || (depModule.type.stateMachine && depModule.actions.find {it.async} )) { %><% if(depModule.facet('jpa')) { %>
    ret.add(${depModule.names.jmsToCdi}.class);<% } %>
    ret.add(${depModule.names.eventToCdi}.class);<% } %><%if(depModule.facet('jpa') && depModule.services) { %>
    ret.add(${depModule.capShortName}ProducerClient.class);
    ret.add(${depModule.capShortName}ProducerEjbClient.class);<% depModule.services.each { service-> %>
    ret.add(${service.names.provider}.class);<%}}}%><% depModule.configs.each { config-> %>
    ret.add(${config.names.clazz}.class);<% } %><% if(depModule.type.stateMachine) { depModule.conditions.each { condition-> %>
    ret.add(${condition.names.clazz}.class);<% } %>
    ret.add(${depModule.names.eventFactoryImpl}.class);
    ret.add(${depModule.names.metaModel}.class);<%  depModule.states.each { state-> %>
    ret.add(${state.names.metaState}.class);<% } } } %>

    return ret;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.shared.module.cdiConfigurationTestBase = '''<% def className = "${module.names.classPrefix}TestCdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;<% module.dependModules.each { depModule -> if(depModule.type.backend && depModule.entities) { %>
import ${depModule.namespaces.model}.ejb.${depModule.names.dataFactory}Ejb;
import ${depModule.namespaces.integ}.receiver.*;<% } %><% if(depModule.type.stateMachine) { depModule.actions.findAll { it.async }.each { action-> %>
import ${depModule.namespaces.integ}.receiver.${action.names.event}Receiver;<% } } } %>

/** Definition of CDI test beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  
  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();<% module.dependModules.each { depModule -> if(depModule.type.backend) { if(depModule.entities) { %><% if(depModule.facet('jpa')) { %>
    ret.add(${depModule.names.dataFactory}Ejb.class);<% } %><% depModule.entities.each { entity-> if(entity.event) { %>
    ret.add(${entity.names.event}Receiver.class);<% } } } %><% depModule.containers.each { container-> %>
    ret.add(${container.names.event}Receiver.class);<% } } %><% if(depModule.type.stateMachine) { depModule.actions.findAll { it.async }.each { action-> %>
    ret.add(${action.names.event}Receiver.class);<% } } } %>
    return ret;
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.shared.module.mlBase = '''<% def className = "${shared.names.ml}Base" %>
$macros.header
package ${destModule.namespaces.integ};

/** Multi language constants for '$module.name' */
public class $className {
  // base name for '$module.name' resource bundle
  public static final String ML_BASE = "${component.artifact}.ml_${component.artifact}";<% module.dependModules.each { depModule -> if(depModule.type.backend) { depModule.entities.each { def entity-> def manager = entity.manager; %>
  public static final String $entity.names.mlKeyConstant = "$entity.names.mlKey";<% if(manager && !entity.virtual) { manager.updators.each { def op -> %>
  public static final String $op.names.mlKeyConstant = "$op.names.mlKey";<% } } } %><% depModule.containers.each { def container-> %>
  public static final String $container.names.mlKeyConstant = "$container.names.mlKey";
  public static final String ${container.names.mlKeyConstant}_IMPORTED = "${container.names.mlKey}_imported";
  public static final String ${container.names.mlKeyConstant}_IMPORT_FAILED = "${container.names.mlKey}_import_failed";
  public static final String ${container.names.mlKeyConstant}_DELETED = "${container.names.mlKey}_deleted";<% } } %>
  <% depModule.configs.each { def config -> %>
  public static final String $config.names.mlKeyConstant = "$config.names.mlKey";
  public static final String ${config.names.mlKeyConstant}_UPDATED = "${config.names.mlKey}_updated";<% } %><% if(depModule.type.stateMachine) { depModule.conditions.collect { cond -> cond.names.failMl }.each { failMl -> %>
  public static final String ${failMl} = "${failMl.toLowerCase()}";<% } } } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

memory.backend.module.initializerMem = '''<% def className = "${module.names.initializer}Mem" %>
$macros.header
package ${module.namespaces.integ}.mem;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.app.event.LifecycleEvent;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${module.namespaces.integ}.${module.names.initializer}Base;

/** Initializer bean for 'module.name' for memory mode */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { MEMORY }))
public class $className extends ${module.names.initializer}Base {

  public void onLifecycleEvent(@Observes(notifyObserver = Reception.ALWAYS) LifecycleEvent event) {
    try {
      super.init();
      // add additional startup tasks here
    } catch (Exception e) {
      log.error("$className failed", e, event);
    }
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/mem/${className}.java" %>'''

common.backend.module.initializer = '''<% def className = "${module.names.initializer}" %>
$macros.header
package ${module.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.annotation.PostConstruct;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.inject.Inject;
import ${module.namespaces.integ}.${className}Base;
import ${module.namespaces.integ}.${module.names.initializer}Base;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

/** Initializer bean for '$component.name' */
@Singleton
@Startup
@SupportsEnvironments(@Environment(runtimes = { SERVER }))
public class $className extends ${className}Base {

  @Override
  @PostConstruct
  public void init() {
    try {
      super.init();
      // add additional startup tasks here
    } catch (Exception e) {
      log.error("$className failed", e);
    }
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.module.initializerBase = '''<% def className = "${module.names.initializer}Base" %>
$macros.header
package ${destModule.namespaces.integ};

import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;
<% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
import ${module.namespaces.core}.${module.names.stateTimeoutHandler};<% } } %>

/** Initialiter for '$module.name' */
public class $className {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  <% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
  private $module.names.stateTimeoutHandler $module.names.stateTimeoutHandlerInstance;<% } } %>

  public void init() {<% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
    ${module.names.stateTimeoutHandlerInstance}.registerTimer();<% } } %>
  }<% if(module.type.stateMachine) { if(module.timeoutEnabled) { %>
  
  @Inject
  public void set$module.names.stateTimeoutHandler($module.names.stateTimeoutHandler $module.names.stateTimeoutHandlerInstance) {
    this.$module.names.stateTimeoutHandlerInstance = $module.names.stateTimeoutHandlerInstance;
  }<% } } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.backend.module.builderFactory = '''<% if(module.entities) { def className = "${module.names.builderFactory}" %>
$macros.header
package ${destModule.namespaces.model}.builder;

import ${destModule.namespaces.model}.ejb.builder.*;
import ${destModule.namespaces.model}.impl.builder.*;

/** Implementation of builder factory for '$module.name' */
public class $className extends ${module.names.builderFactory}Base {
 
  // Add specific builder factory methods here:

  // We have to repeat all factory method declarations from the super class as workaround for a strange 
  // Eclipse bug. Normally it should be enough to add a static import for this class even if static methods
  // from the super class are used. Unfortunately Eclipse automatically adds a static import also for the super 
  // class only to complain that this import is not used. At the moment, I don't see a better way to avoid this 
  // compiler warning.
  <% module.entities.each { entity-> if (!entity.virtual) { if (module.facet('entityImpl')) { %>
  public static ${entity.names.implBuilder} a${entity.name}() {
    return ${module.names.builderFactory}Base.a${entity.name}();
  }<% } %><% if(module.facet('jpa')) { %>
  
  public static ${entity.names.beanBuilder} a${entity.names.bean}() {
    return ${module.names.builderFactory}Base.a${entity.names.bean}();
  }<% } } } %>
}
<% ret.overwrite = false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

common.backend.module.builderFactoryBase = '''<% if(module.entities) { def className = "${module.names.builderFactory}Base" %>
$macros.header
package ${destModule.namespaces.model}.builder;

import ${destModule.namespaces.model}.ejb.builder.*;
<% if (module.facet('entityImpl')) { %>import ${destModule.namespaces.model}.impl.builder.*;<% } %>

/** Base implementation of builder factory for '$module.name' */
public abstract class $className {<% module.entities.each { entity-> if (!entity.virtual) { if (module.facet('entityImpl')) { %>
  
  public static ${entity.names.implBuilder} a${entity.name}() {
    return new ${entity.names.implBuilder}();
  }<% } %><% if(module.facet('jpa')) { %>
  
  public static ${entity.names.beanBuilder} a${entity.names.bean}() {
    return new ${entity.names.beanBuilder}();
  }
  <% } } } %>
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

common.backend.module.cdiConfigurationBase = '''<% def className = "${module.names.classPrefix}CdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;
import ${destModule.namespace}.core.*;<% if(module.entities || module.controllers || module.type.stateMachine) { %>
import ${destModule.namespace}.core.impl.*;
import ${destModule.namespaces.core}.mem.*;<% } %>
import ${destModule.namespaces.integ}.mem.*;
import ${destModule.namespaces.integ}.ejb.*;<% if(destModule.facet('jpa') && destModule.entities) { %>
import ${destModule.namespaces.integ}.jse.*;<% } %><% module.configs.each { config-> if(config.controller) { %>
import ${config.controller.nameFull('impl')};<% } } %><% if(module.type.stateMachine) { %>
import ${destModule.namespaces.core}.impl.${module.controller.names.impl};<% if(module.timeoutEnabled) { %>
import ${destModule.namespaces.core}.mem.${module.names.stateTimeoutHandlerMem};<% } %><% module.states.each { state-> %>
import ${destModule.namespaces.core}.impl.${state.names.eventProcessorImpl};<% } %><% module.actions.each { action-> if(!action.body && !action.async) { %>
import ${destModule.namespaces.core}.impl.${action.names.impl};<% } } %><% } %><% if (component.componentProfile) { %>
import ${destModule.namespaces.model}.impl.${module.capShortName}ComponentProfileImpl;
import ${destModule.namespaces.core}.impl.${module.capShortName}ProfileManagerImpl;<% } %><% if(destModule.services) { %>
import ${destModule.namespace}.facade.ejb.*;<% } %>

/** Definition of CDI beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();
    ret.add(${module.names.initializer}.class);
    ret.add(${module.names.initializer}Mem.class);<% if(module.containers.find { it.controller.cache }) { %>
    ret.add(${module.names.cache}.class);<% } %><% if(component.facet('jpa') && (module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} ))) { %>
    ret.add(${module.names.cdiToJms}.class);<% } %><% if(module.entities) { %>
    ret.add(${module.names.converter}.class);<% } %><% if(module == component.backend) { %> <% if(component.facet('jpa') && module.entities) { %>
    ret.add(${component.capShortName}ProducerServer.class);
    ret.add(${component.capShortName}ProducerLocal.class);<% } %><% } %><% if(module.facet('jpa')) { module.entities.each { entity-> def manager = entity.manager; %><% if(manager && !entity.virtual) { %>
    ret.add(${manager.names.impl}.class);
    ret.add(${manager.names.mem}.class);<% } } %><% } %><% module.configs.each { config-> if(config.controller) { %>
    ret.add(${config.controller.names.impl}.class);<% } } %><% module.controllers.each { controller-> %>
    ret.add(${controller.names.impl}.class);<% } %><% if(module.containers) { %>
    ret.add(${module.capShortName}ContainerProducerInternal.class);<% } %><% module.containers.each { container-> if(container.controller) { %>
    ret.add(${container.controller.names.impl}.class);<% } } %><% if(module.type.stateMachine) { %>
    ret.add(${module.controller.names.impl}.class);<% module.states.each { state-> %>
    ret.add(${state.names.eventProcessorImpl}.class);<% } %><% module.actions.each { action-> if(!action.body && !action.async) { %>
    ret.add(${action.names.impl}.class);<% } } %><% } %><% if (component.componentProfile) { %>
    ret.add(${module.capShortName}ComponentProfileImpl.class);
    ret.add(${module.capShortName}ProfileManagerImpl.class);<% } %><% module.services.each { service-> %>
    ret.add(${service.names.bean}.class);<% } %>
    return ret;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.backend.module.cdiConfigurationTestBase = '''<% def className = "${module.names.classPrefix}TestCdiConfigurationBase" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;<% if(module.type.stateMachine) { %>
import ${module.namespaces.core}.${module.controller.names.clazz}LocalTestInteg;
import ${module.namespaces.core}.${module.controller.names.clazz}MemoryTestInteg;<% } %>

/** Definition of CDI test beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {
  @Override
  
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();<% if(module.type.stateMachine) { %>
    ret.add(${module.controller.names.clazz}LocalTestInteg.class);
    ret.add(${module.controller.names.clazz}MemoryTestInteg.class);<% } %><% if(module.type.stateMachine) { %><% if(module.timeoutEnabled) { %>
    ret.add(${module.names.stateTimeoutHandlerMem}.class);<% } %><% if(module.facet('aal')?.enabled && module.aal) { %><% } %><% } %>
    return ret;
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

jpa.backend.module.cdiToJms = '''<% if(module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = module.names.cdiToJms %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import java.util.ArrayList;

import javax.annotation.Resource;
import javax.ejb.Stateless;
import javax.enterprise.event.Observes;
import javax.inject.Inject;
import javax.jms.ConnectionFactory;
import javax.jms.Topic;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.Factory;
import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;<% if(module.facet('entityImpl')) { %>
import ${destModule.namespaces.model}.${module.names.modelFactory};<% } %>

import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import javax.enterprise.inject.Default;
import com.siemens.ra.cg.pl.common.base.messaging.Event;
import com.siemens.ra.cg.pl.common.base.messaging.impl.EventImpl;
import com.siemens.ra.cg.pl.common.ejb.messaging.JmsSendExecutor;

import ${destModule.namespaces.model}.event.*;
import ${component.namespaces.integ}.$component.names.qualifier;<% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>
import ${destModule.namespaces.model}.event.${action.names.event};<% } } } %>


/** Cdi to Jms bridge for '$module.name' */
@Stateless
@SupportsEnvironments(@Environment(runtimes = { SERVER }))
public class $className {

  private final static XLogger LOG = XLoggerFactory.getXLogger(${className}.class);

  protected JmsSendExecutor sender = new JmsSendExecutor();
  
  @Resource(mappedName = JMS_CONNECTION_FACTORY)
  protected ConnectionFactory connectionFactory;

  @Resource(mappedName = JMS_NOTIFICATION_TOPIC)
  protected Topic notificationTopic;<% if(module.facet('entityImpl')) { %>
  
  @Inject
  protected ${module.names.modelFactory} modelFactory;

  @SuppressWarnings("unchecked")
  protected <T> Event<T> prepareBeforeSent(Event<T> event) {
    if (CollectionUtils.isNotEmpty(event.getObjectList())) {
      Factory<T> factory = (Factory<T>) modelFactory.findFactoryByType(event.getObjectType());
      if (factory != null) {
        ((EventImpl<T>) event).setObjectList(factory.convertList(event.getObjectList()));
      }
    }
    return event;
  }<% } %><% module.entities.each { entity-> if(entity.event) { %>

  public void on$entity.names.event(@Observes @$component.names.qualifier @Backend $entity.names.event event) {
    send(event);
  }<% } } %><% module.configs.each { config -> if(config.event) { %>

  public void on$config.names.event(@Observes @$component.names.qualifier @Backend $config.names.event event) {
    send(event);
  }<% } } %><% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>

  public void on$action.names.event(@Observes @$component.names.qualifier @Backend $action.names.event event) {
    send(event);
  }<% } } } %><% module.containers.each { container-> %>

  public void on$container.names.event(@Observes @$component.names.qualifier @Backend $container.names.event event) {
    send(event);
  }<% } %>

  protected <T> void send(Event<T> event) {
    if (notificationTopic != null && connectionFactory != null) {<% if(module.facet('entityImpl')) { %>
      sender.send(prepareBeforeSent(event), notificationTopic, connectionFactory);<% } else { %>
      sender.send(event, notificationTopic, connectionFactory);<% } %>
    } else {
      LOG.error("Can not send JMS message, because EJB resources not initialized, notificationTopic={}, connectionFactory={}", notificationTopic, connectionFactory);
    }
  }  
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

jpa.component.module.notificationPlugin = '''<% def modules = []; modules.addAll(component.backends.findAll { m -> m.entities } );  modules.addAll(component.stateMachines.findAll { m -> (m.type.stateMachine && m.actions.find {it.async} ) } ) %><% if(modules) { %><% def className = component.names.notificationPlugin %>
$macros.header
package ${destModule.namespaces.integ}.jse;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
<% modules.each { m -> %>
import ${m.namespaces.integ}.jse.$m.names.jmsToCdi;<% } %>
import com.siemens.ra.cg.pl.common.app.core.PluginActivator;
import com.siemens.ra.cg.pl.common.app.event.LifecycleEvent;
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

@Traceable
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { CLIENT }))
public class $className extends PluginActivator {

  public static final String ID = ${className}.class.getName();
  <% modules.each { m -> %>
  private $m.names.jmsToCdi ${m.names.jmsToCdi.uncapitalize()};<% } %>

  public $className() {
    super(ID);
  }

  @Override
  protected void initialize(LifecycleEvent event) {<% modules.each { m -> %>
    ${m.names.jmsToCdi.uncapitalize()}.initialize();<% } %>
  }

  @Override
  protected void shutdown(LifecycleEvent event) {<% modules.each { m -> %>
    ${m.names.jmsToCdi.uncapitalize()}.close();<% } %>
  }<% modules.each { m -> %>
  
  @Inject
  public void set$m.names.jmsToCdi($m.names.jmsToCdi ${m.names.jmsToCdi.uncapitalize()}) {
    this.${m.names.jmsToCdi.uncapitalize()} = ${m.names.jmsToCdi.uncapitalize()};
  }<% } %>
}
<% ret.path = "${destModule.shared.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/jse/${className}.java" %><% } %>'''


jpa.backend.module.cdiToJmsTest = '''<% if(module.entities || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = "${module.names.cdiToJms}Test" %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static org.mockito.Mockito.*;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.Mockito;

import javax.jms.ConnectionFactory;
import javax.jms.Topic;

import com.siemens.ra.cg.pl.common.ejb.messaging.JmsSendExecutor;
import ${destModule.namespaces.model}.event.*;

public class $className { 

  protected static $module.names.cdiToJms cdiToJms;
  
  @BeforeClass
  public static void beforeClass$className() {
    cdiToJms = new $module.names.cdiToJms();    
    cdiToJms.connectionFactory = mock(ConnectionFactory.class);
    cdiToJms.notificationTopic = mock(Topic.class);
    cdiToJms.sender = mock(JmsSendExecutor.class);
  }
  
  @After
  public void after$className() {
    verifyNoMoreInteractions();
  }

  @Before
  public void before$className() {
    resetMocks();
  }

  protected void verifyNoMoreInteractions() {
    Mockito.verifyNoMoreInteractions(cdiToJms.sender);
  }

  protected void resetMocks() {
    Mockito.reset(cdiToJms.sender);
  }<% module.entities.each { entity-> if(entity.event) { %>

  @Test
  public void testOn${entity.names.event}() {
    ${entity.names.event} event = mock(${entity.names.event}.class);
    cdiToJms.on${entity.names.event}(event);
    verify(cdiToJms.sender).send(event, cdiToJms.notificationTopic, cdiToJms.connectionFactory);
  }<% } } %><% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>

  @Test
  public void testOn${action.names.event}() {
    ${action.names.event} event = mock(${action.names.event}.class);
    cdiToJms.on${action.names.event}(event);
    verify(cdiToJms.sender).send(event, cdiToJms.notificationTopic, cdiToJms.connectionFactory);
  }<% } } } %><% module.containers.each { container-> %>

  @Test
  public void testOn${container.names.event}() {
    ${container.names.event} event = mock(${container.names.event}.class);
    cdiToJms.on${container.names.event}(event);
    verify(cdiToJms.sender).send(event, cdiToJms.notificationTopic, cdiToJms.connectionFactory);
  }<% } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

jpa.backend.module.jmsToCdiMdb = '''<% if(module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = "${module.names.jmsToCdi}Mdb" %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.messaging.EventListener;
import com.siemens.ra.cg.pl.common.ejb.messaging.SingleTypeEventListenerBridgeByJms;
import ${shared.namespaces.integ}.$module.shared.names.constants;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespaces.integ}.$module.names.eventToCdi;

/** Jms to Cdi MDB for '$module.name'*/
/** Copy the MDB to other component to receiving JMS events of the module. "
@MessageDriven(mappedName = ${module.shared.names.constants}.JMS_NOTIFICATION_TOPIC,
               activationConfig = {
                   @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = ${module.shared.names.constants}.JMS_NOTIFICATION_TOPIC),
                   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),
                   @ActivationConfigProperty(propertyName = "topicMessagesDistributionMode", propertyValue = "One-Copy-Per-Application")
               }) */
public class $className extends SingleTypeEventListenerBridgeByJms<Object> {

  @Inject
  public void setEventListener($module.names.eventToCdi eventListener) {
    super.setEventListener(eventListener);
  }
}
<% ret.path = "${module.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

jpa.backend.module.jmsToCdi = '''<% if(module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = module.names.jmsToCdi %>
$macros.header
package ${destModule.namespaces.integ}.jse;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.ejb.locator.ServiceLocator;
import com.siemens.ra.cg.pl.common.ejb.messaging.JmsDestinationConfig;
import com.siemens.ra.cg.pl.common.ejb.messaging.jse.JmsToEventListener;
import ${destModule.namespaces.integ}.$module.names.eventToCdi;
import ${component.namespaces.integ}.$component.names.qualifier;

/** Jms to Cdi bridge for '$module.name' */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { CLIENT }))
@Traceable
public class $className extends JmsToEventListener {

  @Override
  @Inject
  public void setDestinationConfig(@$component.names.qualifier JmsDestinationConfig destinationConfig) {
    super.setDestinationConfig(destinationConfig);
  }

  @Inject
  public void setEventListener($module.names.eventToCdi eventListener) {
    super.setEventListener(eventListener);
  }

  public void onChangeServiceLocator(@Observes(notifyObserver = Reception.IF_EXISTS) ServiceLocator serviceLocator) {
    super.setServiceLocator(serviceLocator);
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/jse/${className}.java" %><% } %>'''

common.backend.module.eventToCdi = '''<% if(module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = module.names.eventToCdi %>
$macros.header
package ${destModule.namespaces.integ};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Event;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

/** Listener for Cdi to Jms bridge for '$module.name' */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { CLIENT, SERVER }))
@Traceable
public class $className extends ${className}Base {
  
  @PostConstruct
  @Override
  protected void postConstruct() {
    super.postConstruct();
    
  }
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.component.module.jpaSchemaGenerator = '''<% if(destModule.entities) { %><% def className = "${destModule.capShortName}SchemaGenerator"; def entity = destModule.entities.find { !it.virtual }; %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import javax.ejb.Stateless;
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.inject.Inject;
import javax.persistence.EntityManager;

import ${component.namespaces.integ}.$component.names.qualifier;
import com.siemens.ra.cg.pl.common.ejb.schemagen.DbSchemaGenerator;

@Stateless
//each DDL operation is COMMIT operation, therefore Container Transaction Management must be disabled
@TransactionManagement(TransactionManagementType.BEAN)
public class $className {
  private EntityManager entityManager;

  public $className() {
    super();
  }

  public $className(EntityManager entityManager) {
    super();
    this.entityManager = entityManager;
  }

  public void createSchema() {
    // create db schema
    DbSchemaGenerator generator = new DbSchemaGenerator();
    generator.createSchema(entityManager, "$entity.names.bean");
  }

  @Inject
  public void setEntityManager(@${component.names.qualifier} EntityManager entityManager) {
    this.entityManager = entityManager;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.shared.module.componentMl = '''<% def className = "${destModule.names.ml}" %>
$macros.header
package ${destModule.namespaces.integ};

/** Multi language constants for '$module.name' */
public class $className extends ${shared.names.ml}Base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

jpa.component.module.producer = '''<% def className = "${component.capShortName}Producer" %>
$macros.header
package ${shared.namespaces.integ};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.ejb.messaging.JmsDestinationConfig;
import com.siemens.ra.cg.pl.common.ejb.messaging.JmsDestinationConfigImpl;

/** Resources producer for '$module.name' for server and client in production mode */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { CLIENT, SERVER }))
@Traceable
public class $className {

  private JmsDestinationConfigImpl notificationTopic =
    new JmsDestinationConfigImpl(JMS_NOTIFICATION_TOPIC, JMS_CONNECTION_FACTORY, false);

  @Produces
  @${component.names.qualifier}
  public JmsDestinationConfig getNotificationTopicConfig() {
    return notificationTopic;
  }
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.backend.module.producerClient = '''<% if(module.services) { %><% def className = "${module.capShortName}ProducerClient" %>
$macros.header
package ${shared.namespaces.integ}.jse;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Instance;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.ejb.locator.ReconnectServiceProvider;<% module.services.each { service-> %>
import ${module.namespace}.facade.$service.name;
import ${module.namespace}.facade.provider.$service.names.provider;<% } %>

/** Client CDI resources producer for '$module.name' */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { CLIENT }))
@Traceable
public class $className {<% module.services.each { service-> %>

  @Inject
  private Instance<${service.names.provider}> ${service.uncapName}ProviderDef;<% } %><% module.services.each { service-> %>

  @Produces
  public $service.name get$service.name() {
    $service.name ret = new ReconnectServiceProvider<>(${service.uncapName}ProviderDef.get()).getService();
    return ret;
  }<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/jse/${className}.java" %><% } %>'''

common.backend.module.producerEjbClient = '''<% if(module.services) { %><% def className = "${module.capShortName}ProducerEjbClient" %>
$macros.header
package ${shared.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.ejb.EJB;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.ejb.locator.ServiceLocatorFactory;<% module.services.each { service-> %>
import ${destModule.namespaces.facade}.$service.names.clazz;<% } %>

/** Producer of '$module.name' services for ejb clients in production mode */
@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }))
@Traceable
public class $className {
  <% module.services.each { service-> %>
  private $service.names.clazz $service.names.instance;<% } %><% module.services.each { service-> %>

  @Produces
  public $service.names.clazz get$service.names.clazz() {
    if ($service.names.instance == null) {
      $service.names.instance = ServiceLocatorFactory.getInstance().getBean(SERVICE_${service.underscoredName}, ${service.names.clazz}.class);
    }
    return $service.names.instance;
  }<% } %>
  <% module.services.each { service-> %>

  //TODO: EE we have to use name and mappedName because of bug in WLS, SR #3-7159405421
  @EJB(name = SERVICE_${service.underscoredName}, mappedName = SERVICE_${service.underscoredName})
  public void set${service.names.clazz}(${service.names.clazz} $service.names.instance) {
    this.$service.names.instance = $service.names.instance;
  }<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.component.module.constants = '''<% def className = "${shared.names.constants}" %>
$macros.header
package ${shared.namespaces.integ};

/** Constants for '$module.name' */
public class $className extends ${shared.names.constants}Base {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${shared.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.component.module.constantsBase = '''<% def className = "${shared.names.constants}Base" %>
$macros.header
package ${shared.namespaces.integ};

/** Constants for '$module.name' */
public class $className {<% if(component.facet('jpa')) { %>
  public static final String PERSISTENCE_UNIT = "${component.uncapShortName}Pu";
  public static final String PERSISTENCE_UNIT_LOCAL = "${component.uncapShortName}PuLocal";

  public static final String JMS_CONNECTION_FACTORY = "jms/cg/${component.uncapShortName}/ConnectionFactory";
  public static final String JMS_NOTIFICATION_TOPIC = "jms/cg/${component.uncapShortName}/NotificationTopic";
  public static final String JMS_IMPORT_QUEUE = "jms/cg/${component.uncapShortName}/ImportQueue";
  <% module.shared.dependModules.each { depModule -> %><% if(depModule.type.backend) { %><% depModule.services.each { service-> %>
  public static final String SERVICE_${service.underscoredName} = "$service.name";<% } %><% depModule.containers.each { container -> %>
  public static final String JMS_MESSAGE_SELECTOR_${container.underscoredName} = "$container.uncapName";<% if (depModule.facet('xml') && container.xml) { %>
  public static final String JMS_MESSAGE_SELECTOR_${container.underscoredName}_DATA = "${container.uncapName}_data";<% } } } } %><% } %>
  <% if (component.componentProfile) { %>
  // component profile filename
  public static final String COMPONENT_PROFILE_FILENAME = "/${component.artifact}/${component.componentProfile.cfgFile}";
  public static final String COMPONENT_PROFILE_NAME_PREFIX = "component";
  public static final String COMPONENT_PROFILE_NAME = "${component.artifact}";

  // component profile keys<% component.componentProfile.props.each { prop -> %>
  public static final String COMPONENT_PROFILE_${prop.underscoredName} = "${prop.name}"; <% } } %>
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/${className}.java" %>'''

common.component.module.realmConstants = '''<% if (component.realm && !component.realm.empty) { %> <% def className = "${component.names.realm}" %>
$macros.header
package ${shared.namespaces.integ};

/** Role related constants for '$module.name' */
public class $className {
  // users<% component.realm.users.each { user -> %>
  public static final String USER_${user.underscoredName} = "${user.uncapName}";
  public static final String PASS_${user.underscoredName} = "${user.pass}";<% } %>
  // groups<% component.realm.groups.each { group -> %>
  public static final String GROUP_${group.underscoredName} = "${group.capName}";<% } %>
  // roles<% component.realm.roles.each { role -> %>
  public static final String ROLE_${role.underscoredName} = "${component.uncapShortName}_${role.name}";<% } %>
  // roles generated out from state machines<%
  def stateMachines = component.stateMachines.findAll{it.generatePermissionsForEvents}
  def eventsMap = new HashMap()
  stateMachines.events.flatten().each{ event-> eventsMap.put(event.name, event)}
  eventsMap.each{ eventEntry-> %>
  public static final String ROLE_${eventEntry.value.underscoredName} = "${component.uncapShortName}_${eventEntry.key}";<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${shared.namespaces.integ.dotsAsPath()}/${className}.java" } %>'''

common.backend.module.containerProducerInternal = '''<% if(module.containers) { %><% def className = "${module.capShortName}ContainerProducerInternal" %>
$macros.header
package ${destModule.namespaces.integ};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.enterprise.inject.Produces;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.cdi.Internal;
import ${destModule.namespaces.core}.*;
import ${destModule.namespaces.model}.*;

/** Server CDI container producer for '$module.name' */
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@Traceable
public class $className {<% module.containers.each { container-> %>
  
  @Inject  
  private $container.controller.names.clazz $container.controller.names.instance;<% } %><% module.containers.each { container-> %>

  @Produces
  @Internal
  public $container.names.clazz get$container.names.clazz () {
    return ${container.controller.names.instance}.loadAll();
  }<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.module.converter = '''<% if(module.entities) { def className = "${module.names.converter}" %>
$macros.header
package ${destModule.namespaces.integ};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespaces.integ}.impl.${module.names.converter}Base;

/** Converter between interface and entities for types of '$module.name' */
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@ApplicationScoped
public class $className extends ${module.names.converter}Base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.module.converterBase = '''<% if(module.entities) { def className = "${module.names.converter}Base" %>
$macros.header
package ${destModule.namespaces.integ}.impl;

import java.util.Collection;
import java.util.List;
import java.util.ArrayList;

import javax.enterprise.inject.Alternative;
import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import javax.enterprise.inject.Default;
import com.siemens.ra.cg.pl.common.base.cdi.Internal;

import ${destModule.namespaces.model}.*;<% if(module.facet('jpa')) { %>
import ${destModule.namespaces.model}.ejb.${module.names.modelFactory}Ejb;<% } else if(module.facet('entityImpl')) { %>
import ${destModule.namespaces.model}.impl.${module.names.modelFactory}Impl;<% } %>

/** Base converter between interface and entities for types of '$module.name' */
@Alternative
public class $className {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  protected $module.names.modelFactory internal;
  protected $module.names.modelFactory external;<% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %>
  
  public $t.names.clazz toInternal($t.names.clazz from) {
    $t.names.clazz ret = internal.get${t.names.clazz}Factory().convert(from);
    return ret;
  }

  public $t.names.clazz toExternal($t.names.clazz from) {
    $t.names.clazz ret = external.get${t.names.clazz}Factory().convert(from);
    return ret;
  }<% } } } %><% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %>

  public List<$t.names.clazz> convert${t.names.clazz}sToInternal(Collection<$t.names.clazz> items) {
    ArrayList<$t.names.clazz> ret = new ArrayList<>();
    for($t.names.clazz item : items) {
      ret.add(toInternal(item));
    }
    return ret;
  }

  public List<$t.names.clazz> convert${t.names.clazz}sToExternal(Collection<$t.names.clazz> items) {
    ArrayList<$t.names.clazz> ret = new ArrayList<>();
    for($t.names.clazz item : items) {
      ret.add(toExternal(item));
    }
    return ret;
  }<% } } } %>

  @SuppressWarnings("unchecked")  
  public <E> E toExternal(E from) {
    E ret;
    if(from == null) {
      ret = null;
    }<% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %> else if(from instanceof $t.names.clazz) {
      ret = (E) toExternal(($t.names.clazz)from);
    }<% } } } %> else {
      ret = from;
    }
    return ret;
  }

  @SuppressWarnings("unchecked")  
  public <E> E toInternal(E from) {
    E ret;
    if(from == null) {
      ret = null;
    }<% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %> else if(from instanceof $t.names.clazz) {
      ret = (E) toInternal(($t.names.clazz)from);
    }<% } } } %> else {
      ret = from;
    }
    return ret;
  }

  @Inject
  public void setInternal(@Internal ${module.names.modelFactory} internal) {
    this.internal = internal;
  }
  
  @Inject
  public void setExternal(${module.names.modelFactory} external) {
    this.external = external;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.module.converterTest = '''<% if(module.entities) { def className = "${module.names.converter}Test" %>
$macros.header
package ${destModule.namespaces.integ}.impl;

public class $className extends ${className}Impl {
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespaces.integ.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.module.converterTestImpl = '''<% if(module.entities) { def className = "${module.names.converter}TestImpl" %>
$macros.header
package ${destModule.namespaces.integ}.impl;

import static org.junit.Assert.*;
import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;

import java.util.List;

import org.junit.Test;
<% if(module.facet('entityImpl')) { %>
import ${destModule.namespaces.model}.impl.${module.names.dataFactory}Impl;<% } else if(module.facet('jpa')) { %>
import ${destModule.namespaces.model}.ejb.${module.names.dataFactory}Ejb;<% } %>
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.integ}.${module.names.converter};

public class $className {
  protected final static ${module.names.dataFactory}Base DATA_FACTORY;  
  protected final static ${module.names.converter} CONVERTER;
  
  static {<% if(module.facet('jpa')) { %>
    DATA_FACTORY = new ${module.names.dataFactory}Ejb(new ${module.names.modelFactory}Ejb());<% } else if(module.facet('entityImpl')) { %>
    DATA_FACTORY = new ${module.names.dataFactory}Impl(new ${module.names.modelFactory}Impl());<% } %>  
    CONVERTER = new ${module.names.converter}();<% if(module.facet('jpa')) { %>
    CONVERTER.setInternal(new ${module.names.modelFactory}Ejb());<% } else if(module.facet('entityImpl')) { %>
    CONVERTER.setInternal(new ${module.names.modelFactory}Impl());<% } %><% if(module.facet('entityImpl')) { %>
    CONVERTER.setExternal(new ${module.names.modelFactory}Impl());<% } else if(module.facet('jpa')) { %>
    CONVERTER.setExternal(new ${module.names.modelFactory}Ejb());<% } %>
  }<% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %>

  @Test
  public void excpectSameObjectByConvert${t.names.clazz}ToInternal() {
    $t.names.clazz entity = DATA_FACTORY.new${t.capName}(1);
    $t.names.clazz convertedEntity = CONVERTER.toInternal(entity);<% t.propsRecursive.each { prop-> if ((!prop.multi || prop.typeRef.typeBasicType) && !prop.typeRef.typeEntity) { %>
    assertThat(convertedEntity.${prop.getter}, is(entity.${prop.getter}));<% } else if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>
    assertThat(convertedEntity.get${prop.capName}${relationIdProp.capName}(), is(entity.get${prop.capName}${relationIdProp.capName}()));<% } } %>
  }

  @Test
  public void excpectSameObjectByConvert${t.names.clazz}ToExternal() {
    $t.names.clazz entity = DATA_FACTORY.new${t.capName}(1);
    $t.names.clazz convertedEntity = CONVERTER.toExternal(entity);<% t.propsRecursive.each { prop-> if ((!prop.multi || prop.typeRef.typeBasicType) && !prop.typeRef.typeEntity) { %>
    assertThat(convertedEntity.${prop.getter}, is(entity.${prop.getter}));<% } else if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>
    assertThat(convertedEntity.get${prop.capName}${relationIdProp.capName}(), is(entity.get${prop.capName}${relationIdProp.capName}()));<% } } %>
  }<% } } } %><% [module.basicTypes, module.entities].each { it.each { t-> %><% if(!t.virtual) { %>

  @Test
  @SuppressWarnings({ "rawtypes", "unchecked" })  
  public void excpectSameObjectsByConvert${t.names.clazz}sToInternal() {
    List originalList = DATA_FACTORY.new${t.capName}List(1,3);
    List<$t.names.clazz> convertedList = CONVERTER.convert${t.names.clazz}sToInternal(originalList);
    assertArrayEquals(originalList.toArray(), convertedList.toArray());     
  }

  @Test
  public void excpectSameObjectsByConvert${t.names.clazz}sToExternal() {
    List<$t.names.clazz> originalList = DATA_FACTORY.new${t.capName}List(1,3);
    List<$t.names.clazz> convertedList = CONVERTER.convert${t.names.clazz}sToExternal(originalList);
    assertThat(convertedList.size(), is(originalList.size()));
    for (int i = 0; i < originalList.size(); i++) {
      $t.names.clazz entity = originalList.get(i);
      $t.names.clazz convertedEntity = convertedList.get(i);<% t.propsRecursive.each { prop-> if ((!prop.multi || prop.typeRef.typeBasicType) && !prop.typeRef.typeEntity) { %>
      assertThat(convertedEntity.${prop.getter}, is(entity.${prop.getter}));<% } else if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>
      assertThat(convertedEntity.get${prop.capName}${relationIdProp.capName}(), is(entity.get${prop.capName}${relationIdProp.capName}()));<% } } %>
    }
  }<% } } } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/impl/${className}.java" %><% } %>'''

entityImpl.backend.module.dataFactoryImpl = '''<% if(module.entities) {def className = "${module.names.dataFactory}Impl" %>
$macros.header
package ${destModule.namespaces.model}.impl;

import java.util.List;
import java.util.Map;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.Internal;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.${module.names.modelFactory};

/** Data factory implementation for '$module.name' based on Internal model factory */
@ApplicationScoped
@Default<% if(!module.facet('jpa')) { %>
@Internal<% } %>
public class $className extends ${module.names.dataFactory}Base {
  
  public $className() {
    super();
  }

  public $className(${module.names.modelFactory} modelFactory) {
    super();
    setModelFactory(modelFactory);
  }
  
  @Inject
  @Override
  public void setModelFactory(${module.names.modelFactory} modelFactory) {
    super.setModelFactory(modelFactory);
  }
}
<% ret.overwrite=false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/impl/${className}.java" %><% } %>'''

jpa.backend.module.dataFactoryEjb = '''<% if(module.entities) {def className = "${module.names.dataFactory}Ejb" %>
$macros.header
package ${destModule.namespaces.model}.ejb;

import java.util.List;
import java.util.Map;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Default;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.Internal;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.${module.names.modelFactory};

/** Data factory implementation for '$module.name' based on Ejb Model Factory */
@ApplicationScoped<% if(!module.facet('entityImpl')) { %>
@Default<% } %>
@Internal
public class $className extends ${module.names.dataFactory}Base {
  
  public $className() {
    super();
  }

  public $className(${module.names.modelFactory} modelFactory) {
    super();
    setModelFactory(modelFactory);
  }
  
  @Inject
  @Override
  public void setModelFactory(@Internal ${module.names.modelFactory} modelFactory) {
    super.setModelFactory(modelFactory);
  }
}
<% ret.overwrite=false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.backend.module.dataFactoryBase = '''<% if(module.entities) { def className = "${module.names.dataFactory}Base" %>
$macros.header
package ${destModule.namespaces.model};

import com.siemens.ra.cg.pl.common.base.util.TimeUtils;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

/** Base implementation of data factory for '$module.name' */
public abstract class $className {
  private final XLogger log = XLoggerFactory.getXLogger(getClass());
  
  protected $module.names.modelFactory modelFactory;<% module.basicTypes.each { basicType-> if(basicType.virtual) { %>

  public void fill${basicType.capName}(${basicType.names.clazz} item, int itemNumber) {
    log.debug("fill${basicType.capName}({}, {})", item, itemNumber);<% basicType.props.each { prop -> if (prop.type == 'String') { %>
    item.set${prop.capName}("$prop.capName" + itemNumber);<% } else if (prop.type == 'Long') { %>
    item.set${prop.capName}(Long.valueOf(itemNumber));<% } else if (prop.type == 'Integer') { %>
    item.set${prop.capName}(Integer.valueOf(itemNumber));<% } else if (prop.type == 'byte[]') { %>
    item.set${prop.capName}(("$prop.capName" + itemNumber).getBytes());<% } else if (prop.type == 'Date') { %>
    item.set${prop.capName}(TimeUtils.now());<% } %><% } %>
  }<% } else { %>

  public ${basicType.names.clazz} new${basicType.capName}(int itemNumber) {
    log.debug("${basicType.uncapName}({})", itemNumber);
    ${basicType.names.clazz} ret = modelFactory.new${basicType.names.clazz}();<% if(basicType.superUnit) { %>
    fill${basicType.superUnit.capName}(ret, basicTypeNumber);<% } %><% basicType.props.each { prop -> if (prop.type == 'String') { %>
    ret.set${prop.capName}("$prop.capName" + itemNumber);<% } else if (prop.type == 'Long') { %>
    ret.set${prop.capName}(Long.valueOf(itemNumber));<% } else if (prop.type == 'byte[]') { %>
    ret.set${prop.capName}(("$prop.capName" + itemNumber).getBytes());<% } else if (prop.type == 'Integer') { %>
    ret.set${prop.capName}(Integer.valueOf(itemNumber));<% } else if (prop.type == 'Date') { %>
    ret.set${prop.capName}(TimeUtils.now());<% } %><% } %>
    return ret;
  }

  public List<${basicType.names.clazz}> new${basicType.capName}List(int fromItemNumber, int toItemNumber) {
    log.debug("${basicType.uncapName}List({}, {})", fromItemNumber, toItemNumber);
    ArrayList<${basicType.names.clazz}> ret = new ArrayList<>();
    for (int i = fromItemNumber; i < toItemNumber; i++) {
      ret.add(new${basicType.capName}(i));
    }
    return ret;
  }<% } } %><% module.entities.each { entity-> if(entity.virtual) { %>

  public void fill${entity.capName}(${entity.names.clazz} entity, int entityNumber) {
    log.debug("fill${entity.capName}({}, {})", entity, entityNumber);<% entity.props.each { prop -> if((!prop.primaryKey || entity.manualId ) && !prop.multi) { if (prop.type == 'String') { %>
    entity.set${prop.capName}("$prop.capName" + entityNumber);<% } else if (prop.type == 'Long') { %>
    entity.set${prop.capName}(Long.valueOf(entityNumber));<% } else if (prop.type == 'Integer') { %>
    entity.set${prop.capName}(Integer.valueOf(entityNumber));<% } else if (prop.type == 'Date') { %>
    entity.set${prop.capName}(TimeUtils.now());<% } } %><% } %>
  }<% } else { %>

  public ${entity.names.clazz} new${entity.capName}(int entityNumber) {
    log.debug("${entity.uncapName}({})", entityNumber);
    ${entity.names.clazz} ret = modelFactory.new${entity.names.clazz}();<% if(entity.superUnit) { %>
    fill${entity.superUnit.capName}(ret, entityNumber);<% } %><% entity.props.each { prop -> if((!prop.primaryKey || entity.manualId ) && !prop.multi) {  if (prop.type == 'String') { %>
    ret.set${prop.capName}("$prop.capName" + entityNumber);<% } else if (prop.type == 'Long') { %>
    ret.set${prop.capName}(Long.valueOf(entityNumber));<% } else if (prop.type == 'Integer') { %>
    ret.set${prop.capName}(Integer.valueOf(entityNumber));<% } else if (prop.type == 'Date') { %>
    ret.set${prop.capName}(TimeUtils.now());<% } } %><% } %>
    return ret;
  }

  public List<${entity.names.clazz}> new${entity.capName}List(int fromEntityNumber, int toEntityNumber) {
    log.debug("${entity.uncapName}List({}, {})", fromEntityNumber, toEntityNumber);
    ArrayList<${entity.names.clazz}> ret = new ArrayList<>();
    for (int i = fromEntityNumber; i < toEntityNumber; i++) {
      ret.add(new${entity.capName}(i));
    }
    return ret;
  }<% } } %>

  public void setModelFactory($module.names.modelFactory modelFactory) {
    this.modelFactory = modelFactory;
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.module.ejbJarXml = '''<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://java.sun.com/xml/ns/javaee" xmlns:ejb="http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd"
    version="3.1">

    <assembly-descriptor>
        <!-- List security roles here -->
        <interceptor-binding>
            <ejb-name>*</ejb-name>
            <interceptor-class>com.siemens.ra.cg.pl.common.ejb.trace.weblogic.TraceMdcInterceptor</interceptor-class>
        </interceptor-binding>
    </assembly-descriptor>
</ejb-jar>
<% ret.overwrite = false; ret.path = "${destModule.resSrc}/META-INF/ejb-jar.xml" %>'''

common.backend.module.eventToCdiBase = '''<% if(module.entities || module.configs || (module.type.stateMachine && module.actions.find {it.async} )) { %><% def className = "${module.names.eventToCdi}Base" %>
$macros.header
package ${destModule.namespaces.integ};

import javax.enterprise.event.Event;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.messaging.impl.MultiTypeCdiEventListener;
import com.siemens.ra.cg.pl.common.base.model.event.ConnectionMetaEvent;<% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>
import ${destModule.namespaces.model}.event.${action.names.event};<% } } } %>
import ${component.namespaces.integ}.$component.names.qualifier;
import ${destModule.namespaces.model}.event.*;

/** Event Listener to Cdi for '$module.name' */
public abstract class $className extends MultiTypeCdiEventListener {

  @Inject
  @$component.names.qualifier
  private Event<ConnectionMetaEvent> connectionMetaEventPublisher;<% module.entities.each { entity-> if(entity.event) { %>
  
  @Inject
  @$component.names.qualifier
  @Backend
  private Event<$entity.names.event> ${entity.names.instance}Publisher;<% } } %><% module.configs.each { config-> if(config.event) { %>
  
  @Inject
  @$component.names.qualifier
  @Backend
  private Event<$config.names.event> ${config.names.instance}Publisher;<% } } %><% module.containers.each { container-> %>
  
  @Inject
  @$component.names.qualifier
  @Backend
  private Event<$container.names.event> ${container.names.instance}Publisher;<% } %><% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>
  
  @Inject
  @$component.names.qualifier
  @Backend
  private Event<${action.names.event}> ${action.uncapName}Publisher;<% } } } %>
  
  protected void postConstruct() {
    registerEventPublisher(ConnectionMetaEvent.class, connectionMetaEventPublisher);<% module.entities.each { entity-> if(entity.event) { %>
    registerEventPublisher(${entity.names.event}.class, ${entity.names.instance}Publisher);<% } } %><% module.configs.each { config -> if(config.event) { %>
    registerEventPublisher(${config.names.event}.class, ${config.names.instance}Publisher);<% } } %><% module.containers.each { container -> %>
    registerEventPublisher(${container.names.event}.class, ${container.names.instance}Publisher);<% } %><% if(module.type.stateMachine) { module.actions.each { action-> if(action.async) { %>
    registerEventPublisher(${action.names.event}.class, ${action.uncapName}Publisher);<% } } } %>
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.backend.module.managerFactoryLocal = '''<% if(module.entities) { def className = "${module.names.managerFactory}Local" %>
$macros.header
package ${destModule.namespaces.integ}.jse;

import javax.enterprise.inject.Alternative;

@Alternative
public class $className extends ${module.names.managerFactory}LocalBase {
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespaces.integ.dotsAsPath()}/jse/${className}.java" %><% } %>'''

jpa.backend.module.managerFactoryLocalBase = '''<% if(module.entities) { def className = "${module.names.managerFactory}LocalBase" %>
$macros.header
package ${destModule.namespaces.integ}.jse;

import javax.enterprise.inject.Alternative;
import javax.enterprise.event.Event;
import javax.persistence.EntityManager;

import ${component.module().namespaces.integ}.jse.${component.capShortName}ProducerLocal;

import ${destModule.namespaces.model}.ejb.builder.*;
import ${destModule.namespaces.core}.*;
import ${destModule.namespaces.core}.impl.*;
import ${destModule.namespaces.model}.event.*;
import ${destModule.namespaces.model}.builder.*;

import com.siemens.ra.cg.pl.common.ejb.integ.TransactionProxyHandler;

@Alternative
public class $className {
  protected EntityManager entityManager;
  
  public $className() {
    entityManager = ${component.capShortName}ProducerLocal.entityManager();
  }<% module.entities.findAll { !it.virtual && it.manager }.each { entity = it; manager = entity.manager; %>
  
  public $manager.name get$manager.capName(Event<$entity.names.event> publisher) {
    $manager.names.impl manager = new $manager.names.impl();
    manager.setEntityManager(entityManager);
    manager.setPublisher(publisher);
    manager.setFactory(new ${entity.names.bean}Factory());
    $manager.names.clazz ret = TransactionProxyHandler.wrapForTransaction(manager, ${manager.names.clazz}.class, entityManager);
    return ret;
  }<% } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/jse/${className}.java" %><% } %>'''

memory.backend.module.managerFactoryMem = '''<% if(module.entities) { %><% def className = "${module.names.managerFactory}Memory" %>
$macros.header
package ${destModule.namespaces.integ}.mem;

import javax.enterprise.inject.Alternative;

@Alternative
public class $className extends ${module.names.managerFactory}MemoryBase {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.integ.dotsAsPath()}/mem/${className}.java" %><% } %>'''

memory.backend.module.managerFactoryMemBase = '''<% if(module.entities) { %><% def className = "${module.names.managerFactory}MemoryBase" %>
$macros.header
package ${destModule.namespaces.integ}.mem;

import javax.enterprise.inject.Alternative;
import javax.enterprise.event.Event;
import javax.persistence.EntityManager;

import ${destModule.namespaces.core}.*;
import ${destModule.namespaces.core}.mem.*;
import ${destModule.namespaces.model}.event.*;

import com.siemens.ra.cg.pl.common.ejb.integ.TransactionProxyHandler;

@Alternative
public class $className {
  
  public $className() {
  }<% module.entities.findAll { !it.virtual && it.manager }.each { entity = it; manager = entity.manager; %>
  
  public $manager.name get$manager.capName(Event<$entity.names.event> publisher) {
    $manager.names.mem ret = new $manager.names.mem();
    ret.setPublisher(publisher);<% if(module.facet('entityImpl')) { %>
    ret.setFactory(new ${entity.names.impl}Factory());<% } else if(module.facet('jpa')) { %>
    ret.setFactory(new ${entity.names.bean}Factory());<% } %> 
    return ret;
  }<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/mem/${className}.java" %><% } %>'''

jpa.backend.module.modelFactoryEjb = '''<% if(module.entities) { %><% def className = "${module.names.modelFactory}Ejb" %>
$macros.header
package ${destModule.namespaces.model}.ejb;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Default;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.cdi.Internal;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.${module.names.modelFactory};
import ${destModule.namespaces.model}.${module.names.modelFactory}Base;
import ${destModule.namespaces.model}.ejb.builder.*;

/** JPA implementation of {@link $module.names.modelFactory} */
@ApplicationScoped
@Traceable<% if(!module.facet('entityImpl')) { %>
@Default<% } %>
@Internal
public class $className extends ${module.names.modelFactory}Base {

  public $className() {<% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>
    $t.names.instance = new ${t.names.bean}Factory();
    addFactory(${t.names.clazz}.class, $t.names.instance);<% } } } %>
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.backend.module.modelFactoryBase = '''<% if(module.entities) { %><% def className = "${module.names.modelFactory}Base" %>
$macros.header
package ${destModule.namespaces.model};

import java.util.HashMap;

import javax.enterprise.inject.Alternative;

import com.siemens.ra.cg.pl.common.base.Factory;
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import ${destModule.namespaces.model}.builder.*;

@Alternative
@Traceable
public class $className implements ${module.names.modelFactory} {
  protected HashMap<Class<?>, Factory<?>> typeToFactory = new HashMap<>();
  <% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>
  protected ${t.names.clazz}Factory $t.names.instance;<% } } } %><% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>

  @Override
  public $t.names.clazz new${t.names.clazz}() {
    return ${t.names.instance}.newInstance();
  }<% } } } %><% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>

  @Override
  public $t.names.factory get${t.names.clazz}Factory() {
    return $t.names.instance;
  }<% } } } %>

  @SuppressWarnings("unchecked")
  @Override
  public <E> Factory<E> findFactoryByType(Class<E> type) {
    Factory<E> ret = (Factory<E>) typeToFactory.get(type);
    return ret;
  }

  protected void addFactory(Class<?> type, Factory<?> factory) {
    typeToFactory.put(type, factory);
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %><% } %>'''

entityImpl.backend.module.modelFactoryImpl = '''<% if(module.entities) { %><% def className = "${module.names.modelFactory}Impl" %>
$macros.header
package ${destModule.namespaces.model}.impl;

import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import javax.enterprise.inject.Default;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.${module.names.modelFactory};
import ${destModule.namespaces.model}.${module.names.modelFactory}Base;
import ${destModule.namespaces.model}.impl.builder.*;

/** Implementation of {@link $module.names.modelFactory} for Impl. model classes*/
@ApplicationScoped
@Traceable
@Default
public class $className extends ${module.names.modelFactory}Base {

  public $className() {<% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>
    $t.names.instance = new ${t.names.impl}Factory();
    addFactory(${t.names.clazz}.class, $t.names.instance);<% } } } %>
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/${className}.java" %><% } %>'''


common.backend.module.modelFactory = '''<% if(module.entities) { %><% def className = module.names.modelFactory %>
$macros.header
package ${destModule.namespaces.model};

import com.siemens.ra.cg.pl.common.base.Factory;
import ${destModule.namespaces.model}.builder.*;

/** Factory for all types of '$module.name' */
public interface $className {<% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>

  $t.names.clazz new${t.names.clazz}();<% } } } %><% [module.basicTypes, module.entities].each { it.each { t -> if(!t.virtual) { %>

  $t.names.factory get${t.names.clazz}Factory();<% } } } %>

  <E> Factory<E> findFactoryByType(Class<E> type);
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.component.module.persistenceXmlDerby = '''<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
    version="2.0">
  <!-- For productive usage -->
  <persistence-unit name="${component.uncapShortName}Pu" transaction-type="JTA">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    <jta-data-source>jdbc/${component.uncapShortName}DS</jta-data-source>
    ${macros.apply('persistenceXmlBeans')}
    <properties>
      <!-- EclipseLink should create the database schema automatically -->
      <property name="eclipselink.ddl-generation" value="create-tables"/>
      <property name="eclipselink.ddl-generation.output-mode" value="database"/>
      <property name="eclipselink.logging.level" value="INFO"/>
      <property name="eclipselink.cache.type.default" value="NONE"/>
      <!--property name="eclipselink.temporal.mutable" value="true"/-->
      <!--property name="eclipselink.profiler" value="QueryMonitor PerformanceProfiler"/-->
      <!--property name="eclipselink.profiler" value="QueryMonitor"/-->
    </properties>
  </persistence-unit>

  <% if (component.hasProfiles()) { %>
  <persistence-unit name="profilePu" transaction-type="JTA">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    <jta-data-source>jdbc/${component.uncapShortName}DS</jta-data-source>

    <class>com.siemens.ra.cg.pl.common.profile.model.ProfileEntity</class>
    <class>com.siemens.ra.cg.pl.common.profile.model.EntryEntity</class>

    <exclude-unlisted-classes>true</exclude-unlisted-classes>

    <properties>
      <property name="eclipselink.ddl-generation" value="drop-and-create-tables" />
      <property name="eclipselink.ddl-generation.output-mode" value="database" />
      <property name="eclipselink.logging.level" value="INFO" />
      <property name="eclipselink.cache.type.default" value="NONE" />
    </properties>
  </persistence-unit>

  <% } %><persistence-unit name="${component.uncapShortName}PuLocal" transaction-type="RESOURCE_LOCAL">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    ${macros.apply('persistenceXmlBeans')}
    <properties>
      <property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver" />
      <property name="javax.persistence.jdbc.url" value="jdbc:derby:memory:CgisDB;create=true" />

      <!-- User / password settings -->
      <property name="javax.persistence.jdbc.user" value="${component.uncapShortName}" />
      <property name="javax.persistence.jdbc.password" value="${component.uncapShortName}" />
      <property name="eclipselink.ddl-generation" value="drop-and-create-tables" />
      <property name="eclipselink.ddl-generation.output-mode" value="both" />
      <!--       <property name="eclipselink.application-location" value="./src-gen/main/cfg/sql" /> -->
      <property name="eclipselink.create-ddl-jdbc-file-name" value="create_tables_${component.uncapShortName}_derby.sql"/>
      <property name="eclipselink.drop-ddl-jdbc-file-name" value="drop_tables_${component.uncapShortName}_derby.sql"/>
      <property name="eclipselink.logging.level" value="INFO"/>
    </properties>
  </persistence-unit>
</persistence>
<% ret.path = "${destModule.srcGenMain}/cfg/derby-persistence.xml" %>'''

jpa.component.module.persistenceXmlTimesTen = '''<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
    version="2.0">
  <!-- For productive usage -->
  <persistence-unit name="${component.uncapShortName}Pu" transaction-type="JTA">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    <jta-data-source>jdbc/${component.uncapShortName}DS</jta-data-source>
    ${macros.apply('persistenceXmlBeans')}
    <properties>
      <property name="eclipselink.target-database" value="com.siemens.ra.cg.pl.common.eclipselink.TimesTenPlatform"/>
      <property name="eclipselink.ddl-generation" value="create-tables"/>
      <property name="eclipselink.ddl-generation.output-mode" value="both"/>
      <property name="eclipselink.create-ddl-jdbc-file-name" value="create_tables_${component.key}_tt.sql"/>
      <property name="eclipselink.drop-ddl-jdbc-file-name" value="drop_tables_${component.key}_tt.sql"/>
      <property name="eclipselink.logging.level" value="INFO"/>
      <property name="eclipselink.cache.type.default" value="NONE"/>
    </properties>
  </persistence-unit>

  <% if (component.hasProfiles()) { %>
  <persistence-unit name="profilePu" transaction-type="JTA">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    <jta-data-source>jdbc/${component.uncapShortName}DS</jta-data-source>
    ${macros.apply('persistenceXmlBeans')}
    <properties>
      <property name="eclipselink.target-database" value="com.siemens.ra.cg.pl.common.eclipselink.TimesTenPlatform"/>
      <property name="eclipselink.ddl-generation" value="create-tables"/>
      <property name="eclipselink.ddl-generation.output-mode" value="both"/>
      <property name="eclipselink.create-ddl-jdbc-file-name" value="create_tables_${component.key}_profile_tt.sql"/>
      <property name="eclipselink.drop-ddl-jdbc-file-name" value="drop_tables_${component.key}_profile_tt.sql"/>
      <property name="eclipselink.logging.level" value="INFO" />
      <property name="eclipselink.cache.type.default" value="NONE" />
    </properties>
  </persistence-unit>

  <% } %><persistence-unit name="${component.uncapShortName}PuLocal" transaction-type="RESOURCE_LOCAL">
    <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
    ${macros.apply('persistenceXmlBeans')}
    <properties>
      <property name="javax.persistence.jdbc.driver" value="com.timesten.jdbc.TimesTenDriver"/>
      <property name="javax.persistence.jdbc.url" value="jdbc:timesten:client:cgdbCs"/>
      <property name="javax.persistence.jdbc.user" value="${component.uncapShortName}"/>
      <property name="javax.persistence.jdbc.password" value="${component.uncapShortName}"/>
      <property name="eclipselink.target-database" value="TimesTen"/>
      <property name="eclipselink.ddl-generation" value="drop-create-tables" />
      <property name="eclipselink.ddl-generation.output-mode" value="both" />
      <!--       <property name="eclipselink.application-location" value="./src-gen/main/cfg/sql" /> -->
      <property name="eclipselink.create-ddl-jdbc-file-name" value="create_tables_${component.uncapShortName}_tt.sql"/>
      <property name="eclipselink.drop-ddl-jdbc-file-name" value="drop_tables_${component.uncapShortName}_tt.sql"/>
      <property name="eclipselink.logging.level" value="INFO"/>
    </properties>
  </persistence-unit>
</persistence>
<% ret.path = "${destModule.srcGenMain}/cfg/timesten-persistence.xml" %>'''

jpa.backend.module.weblogicEjbJarXml = '''<?xml version='1.0' encoding='UTF-8'?>
<wls:weblogic-ejb-jar
    xmlns:wls="http://xmlns.oracle.com/weblogic/weblogic-ejb-jar"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd http://xmlns.oracle.com/weblogic/weblogic-ejb-jar http://xmlns.oracle.com/weblogic/weblogic-ejb-jar/1.2/weblogic-ejb-jar.xsd"><% module.services.each { service -> %>
    <wls:weblogic-enterprise-bean>
        <wls:ejb-name>$service.name</wls:ejb-name>
        <wls:enable-call-by-reference>true</wls:enable-call-by-reference>
    </wls:weblogic-enterprise-bean><% } %>
</wls:weblogic-ejb-jar>
<% ret.path = "${destModule.resSrc}/META-INF/weblogic-ejb-jar.xml.generated" %>'''

jpa.component.module.weblogicJdbcXmlDerby = '''<?xml version='1.0' encoding='UTF-8'?>
<jdbc-data-source xmlns="http://xmlns.oracle.com/weblogic/jdbc-data-source" xmlns:sec="http://xmlns.oracle.com/weblogic/security" xmlns:wls="http://xmlns.oracle.com/weblogic/security/wls" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.oracle.com/weblogic/jdbc-data-source http://xmlns.oracle.com/weblogic/jdbc-data-source/1.0/jdbc-data-source.xsd">
  <name>${component.uncapShortName}DS</name>
  <jdbc-driver-params>
    <url>jdbc:derby://localhost:@cg.db.port@/</url>
    <driver-name>org.apache.derby.jdbc.ClientXADataSource</driver-name>
    <properties>
      <property>
        <name>user</name>
        <value>${component.uncapShortName}</value>
      </property>
      <property>
        <name>portNumber</name>
        <value>@cg.db.port@</value>
      </property>
      <property>
        <name>databaseName</name>
        <value>cgis;create=true</value>
      </property>
      <property>
        <name>serverName</name>
        <value>localhost</value>
      </property>
    </properties>
    <password-encrypted>${component.uncapShortName}</password-encrypted>
  </jdbc-driver-params>
  <jdbc-connection-pool-params>
    <test-table-name>SQL SELECT 1 FROM SYS.SYSTABLES</test-table-name>
  </jdbc-connection-pool-params>
  <jdbc-data-source-params>
    <jndi-name>jdbc/${component.uncapShortName}DS</jndi-name>
    <global-transactions-protocol>TwoPhaseCommit</global-transactions-protocol>
  </jdbc-data-source-params>
</jdbc-data-source>
<% ret.path = "${destModule.srcGenMain}/cfg/weblogic/${component.uncapShortName}-derby-jdbc.xml" %>'''

jpa.component.module.weblogicJdbcXmlTimesTen = '''<?xml version='1.0' encoding='UTF-8'?>
<jdbc-data-source xmlns="http://xmlns.oracle.com/weblogic/jdbc-data-source" xmlns:sec="http://xmlns.oracle.com/weblogic/security" xmlns:wls="http://xmlns.oracle.com/weblogic/security/wls" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.oracle.com/weblogic/jdbc-data-source http://xmlns.oracle.com/weblogic/jdbc-data-source/1.0/jdbc-data-source.xsd">
  <name>${component.uncapShortName}DS</name>
  <jdbc-driver-params>
    <url>jdbc:timesten:client:cgdbCs</url>
    <driver-name>com.timesten.jdbc.xa.TimesTenXADataSource</driver-name>
    <properties>
      <property>
        <name>user</name>
        <value>${component.uncapShortName}</value>
      </property>
    </properties>
    <password-encrypted>${component.uncapShortName}</password-encrypted>
  </jdbc-driver-params>
  <jdbc-connection-pool-params>
     <test-table-name>SQL SELECT 1 from DUAL</test-table-name>
  </jdbc-connection-pool-params>
  <jdbc-data-source-params>
    <jndi-name>jdbc/${component.uncapShortName}DS</jndi-name>
    <global-transactions-protocol>TwoPhaseCommit</global-transactions-protocol>
  </jdbc-data-source-params>
</jdbc-data-source>
<% ret.path = "${destModule.srcGenMain}/cfg/weblogic/${component.uncapShortName}-tt-jdbc.xml" %>'''

jpa.component.module.weblogicJdbcXmlTimesTenCluster = '''<?xml version='1.0' encoding='UTF-8'?>
<jdbc-data-source xmlns="http://xmlns.oracle.com/weblogic/jdbc-data-source" xmlns:sec="http://xmlns.oracle.com/weblogic/security" xmlns:wls="http://xmlns.oracle.com/weblogic/security/wls" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.oracle.com/weblogic/jdbc-data-source http://xmlns.oracle.com/weblogic/jdbc-data-source/1.0/jdbc-data-source.xsd">
  <name>${component.uncapShortName}DS</name>
  <jdbc-driver-params>
    <url>jdbc:timesten:client:cgdbCs</url>
    <driver-name>com.timesten.jdbc.TimesTenDriver</driver-name>
    <properties>
      <property>
        <name>user</name>
        <value>${component.uncapShortName}</value>
      </property>
    </properties>
    <password-encrypted>${component.uncapShortName}</password-encrypted>
  </jdbc-driver-params>
  <jdbc-connection-pool-params>
    <test-table-name>SQL {call ttadmin.ISDBACTIVE()}</test-table-name>
  </jdbc-connection-pool-params>
  <jdbc-data-source-params>
    <jndi-name>jdbc/${component.uncapShortName}DS</jndi-name>
    <global-transactions-protocol>LoggingLastResource</global-transactions-protocol>
  </jdbc-data-source-params>
</jdbc-data-source>
<% ret.path = "${destModule.srcGenMain}/cfg/weblogic/${component.uncapShortName}-tt-cluster-jdbc.xml" %>'''

jpa.component.module.weblogicJmsXml = '''<?xml version='1.0' encoding='UTF-8'?>
<weblogic-jms xmlns="http://xmlns.oracle.com/weblogic/weblogic-jms" xmlns:sec="http://xmlns.oracle.com/weblogic/security" xmlns:wls="http://xmlns.oracle.com/weblogic/security/wls" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.oracle.com/weblogic/weblogic-jms http://xmlns.oracle.com/weblogic/weblogic-jms/1.1/weblogic-jms.xsd">
  <connection-factory name="${component.uncapShortName}ConnectionFactory">
    <default-targeting-enabled>true</default-targeting-enabled>
    <jndi-name>jms/cg/${component.uncapShortName}/ConnectionFactory</jndi-name>
    <client-params>
      <client-id-policy>Unrestricted</client-id-policy>
      <subscription-sharing-policy>Sharable</subscription-sharing-policy>
      <messages-maximum>10</messages-maximum>
    </client-params>
    <transaction-params>
      <xa-connection-factory-enabled>true</xa-connection-factory-enabled>
    </transaction-params>
    <security-params>
      <attach-jmsx-user-id>false</attach-jmsx-user-id>
    </security-params>
  </connection-factory>
  <uniform-distributed-topic name="${component.uncapShortName}NotificationTopic">
    <sub-deployment-name>${component.uncapShortName}SubDeploy</sub-deployment-name>
    <jndi-name>jms/cg/${component.uncapShortName}/NotificationTopic</jndi-name>
    <forwarding-policy>Partitioned</forwarding-policy>
  </uniform-distributed-topic>
</weblogic-jms>
<% ret.path = "${destModule.srcGenMain}/cfg/weblogic/${component.uncapShortName}-jms.xml" %>'''

jpa.backend.basicType.baseBean = '''<% def className = item.names.baseBean %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;<% def superUnit = item.superUnit; %>
$item.imports
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Embeddable;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.Index;
import javax.persistence.Lob;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;<% if(!superUnit) { %>

import com.siemens.ra.cg.pl.common.base.model.Base;<% } %>

import ${destModule.namespace}.${item.namespace}.*;

/** JPA representation of {@link $item.name} */<% if(!item.base && !item.virtual) { %>
@Embeddable<% } %>
public ${item.virtual?'abstract ':''}class $className extends <% if(superUnit) { %>$superUnit.names.bean<% }else { %>Base<% } %> implements ${item.name} {
  private static final long serialVersionUID = 1L;
  ${macros.apply('propsSqlConstants')}<% item.props.each { prop-> def mapping = prop.mapping; if(mapping) { %>

  $mapping<% } %>
  protected $prop.computedTypeEjbMember $prop.name;<% } %>
  ${macros.apply(name: 'constructors', className: className)}<% item.props.each { prop-> %>

  @Override<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $prop.computedType $prop.getter {
    return <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } %>$prop.name;
  }

  @Override<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public void set${prop.capName}($prop.computedType $prop.name) {
    this.$prop.name = <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } else if(prop.typeRef.typeBasicType) { %>($prop.computedTypeEjbMember)<% } %>$prop.name;
  }<% } %>
  ${macros.apply(name: 'hashCodeAndEquals', className: className)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.basicType.clazz = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.$item.namespace;
$item.imports
/** Base interface for {@link $item.names.base} */
public interface $className extends $item.names.base {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.basicType.base = '''<% def className = item.names.base %>
$macros.header
package ${destModule.namespace}.$item.namespace;<% def superUnit = item.superUnit %>

import java.io.Serializable;
$item.imports
import java.util.Date;
${item.description?"/*** $item.description */":''}
public interface $className extends <% if(superUnit) { %>$superUnit.name<% }else { %>Serializable<% } %> { <% item.props.each { prop-> %>
  ${prop.description?"   /** $prop.description */":''}
  $prop.computedType $prop.getter;

  void set${prop.capName}($prop.computedType $prop.name);<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

jpa.backend.basicType.bean = '''<% if(item.base) { %><% def className = item.names.bean %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;

import javax.persistence.Embeddable;

/** JPA representation of {@link $item.name} */
@Embeddable
public class $className extends $item.names.baseBean {
  private static final long serialVersionUID = 1L;
  ${macros.apply(name: 'constructorsSuper', className: className)}
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.backend.config.controllerImpl = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.impl %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.Date;
import java.util.List;
import java.util.Map;
$controller.imports
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespace}.${controller.namespace}.${controller.name};
import ${destModule.namespaces.model}.*;

@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $controller.names.baseImpl {
  ${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.config.event = '''${macros.apply('event')}'''

common.backend.config.eventReceiver = '''<% if(item.event) { %><% def className= "${item.names.event}Receiver" %>
$macros.header
package ${destModule.namespaces.integ}.receiver;

import static javax.enterprise.event.Reception.*;
import static javax.enterprise.event.TransactionPhase.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;

import com.siemens.ra.cg.pl.common.base.cdi.Receiver;
import ${destModule.namespace}.${item.namespace}.event.$item.names.event;

/** Event receiver for JSE environment only  of {@link $item.names.event} */
@ApplicationScoped
public class $className extends Receiver<${item.names.event}> {
  @Override
  public void onEvent(@Observes(during = AFTER_COMPLETION, notifyObserver = IF_EXISTS) $item.names.event event) {
    super.onEvent(event);
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/receiver/${className}.java" %><% } %>'''

common.all.pojo.base = '''<% def className = item.names.base; %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.util.List;

import com.siemens.ra.cg.pl.common.base.model.Base;
$item.imports
${item.description?"/*** $item.description */":''}
public class $className extends Base {
  private static final long serialVersionUID = 1L;
  ${macros.apply(name: 'propMembers', override: false)}
  ${macros.apply(name: 'propMethods', override: false)}
  ${macros.apply(name: 'implOperationsAndDelegates', override: false)}
  ${macros.apply(name: 'propsUpdate', override: false)}
  ${macros.apply(name: 'fillToString')}
}
<% ret.path = "${item.toShared ? destModule.shared.javaSrcGen : destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.all.pojo.clazz = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.$item.namespace;

$item.imports
${item.description?"/*** @see $item.names.base  */":''}
public class $className extends $item.names.base {
  private static final long serialVersionUID = 1L;
}
<% ret.overwrite = false; ret.path = "${item.toShared ? destModule.shared.javaSrc : destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.all.pojo.event = '''${macros.apply('event')}'''

common.backend.config.base = '''<% def className = item.names.base; %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import javax.enterprise.context.ApplicationScoped;
import com.siemens.ra.cg.pl.common.base.config.Config;
import com.siemens.ra.cg.pl.common.base.model.Base;
$item.imports
${item.description?"/*** $item.description */":''}<% if(!item.base) { 
%> @ApplicationScoped @Config<% } %>
public class $className extends Base {
  private static final long serialVersionUID = 1L;  
  /** A unique URI prefix for RESTful services and multi-language support */
  public static final String URI_PREFIX = "$item.uri";
  <% item.props.each { prop-> %>
  protected $prop.computedType $prop.name<% if(prop.defaultValue != null) { %> = ${prop.defaultLiteral}<% if(prop.type == 'Long' || prop.type == 'long') { %>L<% } %><% } %>;<% } %><% item.props.each { prop-> %>
  ${prop.description?"/*** $prop.description */":''}
  public $prop.computedType $prop.getter {
    return $prop.name;
  }

  public void set${prop.capName}($prop.computedType $prop.name) {
    this.$prop.name = $prop.name;
  }<% } %>

  public void update($item.names.clazz $item.names.instance) {<% item.props.each { prop-> %>
    $prop.setterMethodName($item.names.instance.$prop.getter);<% } %>
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.config.clazz = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.$item.namespace;

import javax.enterprise.context.ApplicationScoped;
import com.siemens.ra.cg.pl.common.base.config.Config;
$item.imports
${item.description?"/*** @see $item.names.base  */":''}
@ApplicationScoped
@Config
public class $className extends $item.names.base {
  private static final long serialVersionUID = 1L;
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.config.controller = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.clazz %>
$macros.header
package ${destModule.namespace}.${controller.namespace};
$controller.imports
/**
* The controller $controller.name provides internal logic operations for the config $item.name.<% if(controller.description) { %>
* <p>
* $controller.description
* </p><% } %>
*/
public interface $className extends $controller.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.config.controllerBase = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.base %>
$macros.header
package  ${destModule.namespace}.${controller.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
$controller.imports

import ${item.nameFull()};

<% if(!controller.base) { %>
/**
* The controller $controller.name provides internal logic operations for the container $item.name.<% if(controller.description) { %>
* <p>
* $controller.description
* </p><% } %>
*/<% } else { %>/** Base interface of {@link $controller.name} */<% } %>
public interface $className {
  @Transactional
  $item.names.clazz update($item.names.clazz $item.names.instance);
  $item.names.clazz load();
  ${macros.apply(name: 'interfaceBody', item: controller)}
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.config.controllerBaseImpl = '''<% def controller = item.controller; if(controller) { %><% def className = controller.names.baseImpl %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;<% def refs=controller.refs.logicUnits %>

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.inject.Inject;
import java.util.List;
import java.util.Map;

import javax.enterprise.event.Event;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.util.StringUtils;
import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
${macros.apply(name: 'importRefs', item: controller)}
import ${destModule.namespace}. ${controller.namespace}.${controller.name};
import ${item.nameFull()};
import ${destModule.namespace}.${item.namespace}.event.$item.names.event;
import ${component.namespaces.integ}.$component.names.qualifier;
import ${shared.namespaces.integ}.${shared.names.ml};

<% if(!controller.base) { %>@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })<% } %>
public ${controller.base?'abstract ':''}class $className implements $controller.name {
  protected final String source = StringUtils.formatSource(this);  
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  ${macros.apply(name: 'refsMembers', item: controller)}
  
  protected $item.names.clazz $item.names.instance;  
  protected Event<${item.names.event}> publisher;
  
  @Override
  @Transactional
  public $item.names.clazz update($item.names.clazz $item.names.instance) {
    this.${item.names.instance}.update($item.names.instance);

    $item.names.event event = new ${item.names.event}($item.names.instance, ActionType.UPDATE, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.${item.names.mlKeyConstant}_UPDATED);
    fireEvent(event);
    return $item.names.instance;
  }

  @Override
  public $item.names.clazz load() {
    //TODO EE: implement loading from DB, e.g. with managers
    return $item.names.instance;
  }
  ${macros.apply(name: 'implOperationsAndDelegates', override: true, item: controller)}
  ${macros.apply(name: 'implInjects', item: controller)}

  protected void fireEvent(${item.names.event} event) {
    publisher.fire(event);
  }

  @Inject
  public void set$item.capName($item.names.clazz $item.names.instance) {
    this.$item.names.instance = $item.names.instance;
  }

  @Inject
  public void setPublisher(@$component.names.qualifier @Backend Event<${item.names.event}> publisher) {
    this.publisher = publisher;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.config.properties = '''#$item.description
<% item.props.each { prop-> %>
#$prop.name<% if(prop.defaultValue != null) { %>=${prop.defaultLiteral}<% } } %>
<% ret.path = "${shared.srcGenMain}/cfg/${item.uncapName}.properties" %>'''

common.backend.container.container = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/**
* The container is used to transfer bundled data between between server and client.
* <p>
* ${item.description?item.description:''}
* </p>
*/
public interface $className extends $item.names.base {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.container.containerBase = '''<% def className = item.names.base %><% def entityNames = item.entities.collect { it.name } as Set; def entityToOneToManyNoOppositeProps = [:]; def entityToManyToOneProps = [:]; item.entities.each { entity -> 
      entityToOneToManyNoOppositeProps[entity] = []; entityToManyToOneProps[entity] = []; entity.propsRecursive.each { prop-> if(prop.typeEl) {
        if(prop.oneToMany && !prop.oppositeProp && entityNames.contains(prop.typeEl.name)) { entityToOneToManyNoOppositeProps[entity] << prop }
        if(prop.manyToOne && entityNames.contains(prop.typeEl.name)) { entityToManyToOneProps[entity] << prop } } } } %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.io.Serializable;
import java.util.Date;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.cache.LinkedObjectCache;
import ${destModule.namespaces.model}.*;
import ${destModule.namespace}.${item.namespace}.cache.*;$item.imports

<% if(!item.base) { %>
/**
* The container is used to transfer bundled data between between server and client.
* <p>
* ${item.description?item.description:''}
* </p>
*/<% } else { %>/** Base interface of {@link $item.name} */<% } %>
public interface $className extends Serializable {
  /** A unique URI prefix for RESTful services and multi-language support */
  public static final String URI_PREFIX = "$item.uri";

  /** Source of object builder. E.g. server/node name. */
  String getSource();

  void setSource(String source);

  /** Time point of data fetching */
  Date getTimestamp();

  void setTimestamp(Date timestamp);

  /** Reset temporary ids of new entities */  
  void resetTempIds();

  void synchronize($item.names.clazz container);

  void synchronize($item.names.removes removes);

  void clear();<% item.entities.each { entity -> %>
  
  $entity.cache.names.clazz get${entity.names.clazz}s();<% } %><% entityToOneToManyNoOppositeProps.each { entity, linkedProps -> linkedProps.each { prop-> def relationIdProp = prop.typeEl.idProp %>
  
  LinkedObjectCache<${entity.idProp.computedType}, $relationIdProp.computedType, $prop.typeEl.names.clazz> get${entity.name}${prop.capName}();<% } } %>
  ${macros.apply('interfaceBody')}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.container.containerBaseImpl = '''<% def className = item.names.baseImpl %><% def entityNames = item.entities.collect { it.name } as Set; def entityToOneToManyNoOppositeProps = [:]; def entityToManyToOneProps = [:]; item.entities.each { entity -> 
      entityToOneToManyNoOppositeProps[entity] = []; entityToManyToOneProps[entity] = []; entity.propsRecursive.each { prop-> if(prop.typeEl) { 
        if(((prop.oneToMany && !prop.oppositeProp) || (prop.mm)) && entityNames.contains(prop.typeEl.name)) { entityToOneToManyNoOppositeProps[entity] << prop }
        if(prop.manyToOne && entityNames.contains(prop.typeEl.name)) { entityToManyToOneProps[entity] << prop } } } } %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import ${destModule.namespace}.${item.namespace}.cache.*;
import ${destModule.namespace}.${item.namespace}.cache.impl.*;$item.imports

import com.siemens.ra.cg.pl.common.base.cache.LinkedObjectCache;
import com.siemens.ra.cg.pl.common.base.model.Base;
import com.siemens.ra.cg.pl.common.base.resolver.LongTempIdResolver;
import com.siemens.ra.cg.pl.common.base.util.TimeUtils;
import ${destModule.namespace}.${item.namespace}.*;

public ${item.base?'abstract ':''}class $className extends Base implements $item.name {
  private static final long serialVersionUID = 1L;

  protected String source;
  protected Date timestamp;
  <% item.entities.each { entity -> %>
  protected $entity.cache.names.clazz $entity.names.instances;<% } %><% entityToOneToManyNoOppositeProps.each { entity, linkedProps -> linkedProps.each { prop-> def relationIdProp = prop.typeEl.idProp %>
  protected LinkedObjectCache<${entity.idProp.computedType}, $relationIdProp.computedType, $prop.typeEl.names.clazz> ${entity.uncapName}${prop.capName};<% } } %>
  
  public $className(boolean override) {
    super();
    this.timestamp = TimeUtils.now();
    if(!override) {<% item.entities.each { entity -> %>
      this.$entity.names.instances = new $entity.cache.names.impl();<% } %>
    } else {<% item.entities.each { entity -> %>
      this.$entity.names.instances = new $entity.cache.names.override();<% } %>
    }
    <% entityToOneToManyNoOppositeProps.each { entity, linkedProps -> linkedProps.each { prop-> def relationIdProp = prop.typeEl.idProp %>
    this.${entity.uncapName}${prop.capName} = new LinkedObjectCache<>($prop.typeEl.names.instances);<% } } %>
  }

  public $className($item.name sourceContainer) {
    super();
    this.timestamp = TimeUtils.now();
    <% item.entities.each { entity -> %>
    this.$entity.names.instances = new $entity.cache.names.override();
    (($entity.cache.names.override) this.$entity.names.instances).setParent(sourceContainer.get${entity.names.clazz}s());<% } %>
    <% entityToOneToManyNoOppositeProps.each { entity, linkedProps -> linkedProps.each { prop-> def relationIdProp = prop.typeEl.idProp %>
    this.${entity.uncapName}${prop.capName} = new LinkedObjectCache<>($prop.typeEl.names.instances);<% } } %>
  }

  public $className(String source, boolean override) {
    this(override);
    this.source = source;
  }

  public $className(String source, $item.name sourceContainer) {
    this(sourceContainer);
    this.source = source;
  }
  
  @Override
  public String getSource() {
    return source;
  }

  @Override
  public void setSource(String source) {
    this.source = source;
  }

  @Override
  public Date getTimestamp() {
    return timestamp;
  }

  @Override
  public void setTimestamp(Date timestamp) {
    this.timestamp = timestamp;
  }

  @Override
  public void resetTempIds() {<% item.entities.each { entity -> def type = entity.idProp.computedType; 
    if(type.equalsIgnoreCase('Long') || type.equalsIgnoreCase('Integer')) { %>
    ${entity.names.instances}.resetTempIds();<% } } %>
  }

  @Override
  public void synchronize($item.names.clazz container) {<% item.entities.each { entity -> %>
    ${entity.names.instances}.synchronize(container.get${entity.names.clazz}s());<% } %>
  }

  @Override
  public void synchronize($item.names.removes removes) {<% item.entities.each { entity -> %>
    ${entity.names.instances}.synchronizeRemoves(removes.get${entity.capName}Ids());<% } %>
  }

  @Override
  public void clear() {<% item.entities.each { entity -> %>
    ${entity.names.instances}.clear();<% } %>
  }<% item.entities.each { entity -> %>

  @Override
  public $entity.cache.names.clazz get${entity.names.clazz}s() {
    return ${entity.names.instances};
  }<% } %><% entityToOneToManyNoOppositeProps.each { entity, linkedProps -> linkedProps.each { prop-> def relationIdProp = prop.typeEl.idProp %>
  
  @Override
  public LinkedObjectCache<${entity.idProp.computedType}, $relationIdProp.computedType, $prop.typeEl.names.clazz> get${entity.name}${prop.capName}() {
    return ${entity.uncapName}${prop.capName};
  }<% } } %>
  ${macros.apply(name: 'implOperationsAndDelegates', override: true)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %>'''

common.backend.container.containerRemoves = '''<% def className = item.names.removes %>
$macros.header
package ${destModule.namespace}.${item.namespace};

public class $className extends $item.names.removesBase {
  private static final long serialVersionUID = 1L;
}
<% ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.container.containerRemovesBase = '''<% def className = item.names.removesBase %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

public class $className implements Serializable {
  private static final long serialVersionUID = 1L;<% item.entities.each { entity -> %>
  protected HashSet<$entity.idProp.type> ${entity.names.instance}Ids = new HashSet<>();<% } %><% item.entities.each { entity -> %>

  public Set<$entity.idProp.type> get${entity.capName}Ids() {
    return ${entity.names.instance}Ids;
  }<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.container.containerController = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.clazz %>
$macros.header
package ${destModule.namespace}.${controller.namespace};
$controller.imports
/**
* The controller $controller.name provides internal logic operations for the container $item.name.<% if(controller.description) { %>
* <p>
* $controller.description
* </p><% } %>
*/
public interface $className extends $controller.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.container.containerControllerBase = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.base %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import java.util.List;
import java.util.Map;

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
$controller.imports

import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;

<% if(!controller.base) { %>
/**
* The controller $controller.name provides internal logic operations for the container $item.name.<% if(controller.description) { %>
* <p>
* $controller.description
* </p><% } %>
*/<% } else { %>/** Base interface of {@link $controller.name} */<% } %>
public interface $className {
  @Transactional
  void importContainer($item.names.clazz container);
  @Transactional
  void deleteAll();
  $item.names.clazz loadAll();
  $item.names.info loadInfoAll();
  ${macros.apply(name: 'interfaceBody', item: controller)}
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.container.containerControllerBaseImpl = '''<% def controller = item.controller; if(controller) { %><% def className = controller.names.baseImpl %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;<% def refs=controller.refs.logicUnits %>

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

import javax.inject.Inject;

import java.util.List;
import java.util.Map;

import javax.enterprise.event.Event;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import com.siemens.ra.cg.pl.common.base.util.StringUtils;
$controller.imports<% refs.each { ref-> %>
import ${ref.module().namespace}.${ref.namespace}.${ref.name};<% } %>
import ${destModule.namespaces.core}.*;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;
import ${destModule.namespaces.model}.impl.*;
import ${destModule.namespaces.integ}.${module.names.converter};
import ${destModule.namespace}.${item.namespace}.event.$item.names.event;
import ${component.namespaces.integ}.$component.names.qualifier;
import ${shared.namespaces.integ}.${shared.names.ml};

<% if(!controller.base) { %>@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })<% } %>
public ${controller.base?'abstract ':''}class $className implements $controller.name {
  protected final String source = StringUtils.formatSource(this);
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  <% refs.each { ref-> def uncapName = ref.name.uncapitalize() %>
  protected $ref.name $uncapName;<% } %>

  protected Event<${item.names.event}> publisher;
  protected $module.names.converter converter;<% if(controller.cache) { %>
  protected $module.names.cache cache;
  <% } %>

  @Override
  @Transactional
  public void importContainer($item.names.clazz container) {<% if(controller.deleteBeforeImport) { %>
    deleteAll(false);<% } %>
    container.resetTempIds();
    <% item.entities.each { entity -> %>
    import${entity.names.clazz}s(container);<% } %>

    $item.names.event event = new ${item.names.event}(ActionType.CREATE_MULTIPLE, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.${item.names.mlKeyConstant}_IMPORTED);
    fireEvent(event);<% if(controller.cache) { %>

    cache.set$item.capName(null);<% } %>
  }

  @Override
  @Transactional
  public void deleteAll() {
    deleteAll(true);
  }

  @Transactional
  protected void deleteAll(boolean fireEvent) {<% item.entities.each { entity -> %>
    delete${entity.names.clazz}s();<% } %>

    if(fireEvent) {
      $item.names.event event = new ${item.names.event}(ActionType.DELETE_MULTIPLE, source);
      event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.${item.names.mlKeyConstant}_DELETED);
      fireEvent(event);
    }<% if(controller.cache) { %>

    cache.set$item.capName(null);<% } %>
  }<% item.entities.each { entity -> %>

  protected void delete${entity.names.clazz}s() {
    ${entity.manager.names.instance}.deleteAll(false);
  }<% } %><% if(controller.cache) { %>
  
  @Override
  public $item.names.clazz loadAll() {
    $item.names.clazz ret = cache.get$item.capName();
    if(ret == null) {
      ret = new $item.names.impl(source);
      <% item.entities.each { entity -> %>
      fill${entity.names.clazz}s(ret);<% } %>
      
      cache.set$item.capName(ret);
    }
    return ret;
  }<% } else { %>
  
  @Override
  public $item.names.clazz loadAll() {
    $item.names.impl ret = new $item.names.impl(source);
    <% item.entities.each { entity -> %>
    fill${entity.names.clazz}s(ret);<% } %>
    return ret;
  }<% } %>

  @Override
  public $item.names.info loadInfoAll() {
    $item.names.infoImpl ret = new $item.names.infoImpl(source);
    <% item.entities.each { entity -> %>
    ret.set${entity.names.clazz}sCount(${entity.manager.names.instance}.countAll());<% } %>
    return ret;
  }<% item.entities.each { entity -> %>

  protected void import${entity.names.clazz}s($item.names.clazz container) {
    List<$entity.names.clazz> entities = converter.convert${entity.names.clazz}sToInternal(container.get${entity.names.clazz}s().findNew());
    ${entity.manager.names.instance}.updateAll(entities, false);
  }<% } %><% item.entities.each { entity -> %>

  protected void fill${entity.names.clazz}s($item.names.clazz container) {
    fill${entity.names.clazz}s(container, ${entity.manager.names.instance}.findAll());
  }

  protected void fill${entity.names.clazz}s($item.names.clazz container, List<$entity.names.clazz> entities) {
    List<$entity.names.clazz> items = converter.convert${entity.names.clazz}sToExternal(entities);
    container.get${entity.names.clazz}s().putAll(items);
  }<% } %><% controller.operations.each { op-> if(op.body) { %>

  @Override<% if(op.transactional) { %>
  @Transactional<% } %><% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } %><% } %><% controller.refs.delegates.each { opRef-> def op = opRef.reference()?.op; if(op) { %>

  @Override<% if(op.transactional) { %>
  @Transactional<% } %><% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $opRef.returnType ${opRef.nameExternal}($opRef.signature) {<% if(op.void) { %>
    ${op.parent.uncapName}.${op.name}($op.signatureNames);<% }else { %>
    $opRef.returnType ret = ${op.parent.uncapName}.${op.name}($op.signatureNames);
    return ret;<% } %>
  }
  <% } %><% } %><% refs.each { ref-> def uncapName = ref.name.uncapitalize() %>

  @Inject
  public void set${ref.name}($ref.name $uncapName) {
    this.$uncapName = $uncapName;
  }<% } %>

  @Inject
  public void set${module.names.converter}($module.names.converter converter) {
    this.converter = converter;
  }<% if(controller.cache) { %>
  
  @Inject
  public void setCache($module.names.cache cache) {
    this.cache = cache;
  }<% } %>

  protected void fireEvent(${item.names.event} event) {
    publisher.fire(event);
  }

  @Inject
  public void setPublisher(@$component.names.qualifier @Backend Event<${item.names.event}> publisher) {
    this.publisher = publisher;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.container.containerControllerDelegateTest = '''<% def controller = item.controller; if(controller) { %><% def className = "${controller.name}DelegateTest" %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;

public class $className extends ${className}Base { 
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.container.containerControllerDelegateTestBase = '''<% def controller = item.controller; if(controller) { %><% def className = "${controller.name}DelegateTestBase" %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;<% def refs=controller.refs.logicUnits %>

import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import static com.siemens.ra.cg.pl.common.base.matcher.CommonMatchers.*;

import javax.enterprise.event.Event;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

$controller.imports<% refs.each { ref-> %>
import ${ref.module().namespace}.${ref.namespace}.${ref.names.clazz};<% } %>
import ${destModule.namespaces.core}.*;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.event.*;
import ${destModule.namespaces.model}.ejb.*;
import ${destModule.namespaces.model}.impl.*;
import ${destModule.namespaces.integ}.${module.names.converter};

public abstract class $className { 

  protected static $controller.names.impl controller;
  protected static $item.names.clazz container = new $item.names.impl();<% item.entities.each { entity -> %>
  protected static ArrayList<$entity.names.clazz> ${entity.names.instance}Ejbs  = new ArrayList<>();
  protected static ArrayList<$entity.names.clazz> $entity.names.instances  = new ArrayList<>();<% } %>
  
  @BeforeClass
  @SuppressWarnings("unchecked")  
  public static void beforeClass$className() {
    controller = new $controller.names.impl();<% refs.each { ref-> %>
    controller.set${ref.names.clazz}(mock(${ref.names.clazz}.class));<% } %>
    controller.set${module.names.converter}(mock(${module.names.converter}.class));
    controller.setPublisher(mock(Event.class));<% if(controller.cache) { %>
    controller.setCache(mock(${module.names.cache}.class));<% } %>
  }
  
  @After
  public void after$className() {
    verifyNoMoreInteractions();
  }

  @Before
  public void before$className() {
    resetMocks();
  }

  protected void verifyNoMoreInteractions() {
    Mockito.verifyNoMoreInteractions(<% first = true; refs.each { ref-> if(first) { first = false } else { %>,<% } %>
      controller.${ref.names.instance}<% } %>,
      controller.converter,
      controller.publisher);
  }

  protected void resetMocks() {
    Mockito.reset(<% first = true; refs.each { ref-> if(first) { first = false } else { %>,<% } %>
      controller.${ref.names.instance}<% } %>,
      controller.converter,
      controller.publisher);
  }

  @Test
  public void importContainer() {
    controller.importContainer(container);<% if(controller.deleteBeforeImport) { %>
    verifyDeleteAll();<% } %>
    verifyImportContainer();
  }

  protected void verifyImportContainer() {<% item.entities.each { entity -> %>
    verify(controller.converter).convert${entity.names.clazz}sToInternal(container.get${entity.names.clazz}s().findNew());    
    verify(controller.${entity.manager.names.instance}).updateAll(${entity.names.instance}Ejbs, false);<% } %>
    verify(controller.publisher).fire(($item.names.event) argThat(withActionType(ActionType.CREATE_MULTIPLE)));
  }

  @Test
  public void deleteAll() {
    controller.deleteAll();
    verifyDeleteAll();
    verify(controller.publisher).fire(($item.names.event) argThat(withActionType(ActionType.DELETE_MULTIPLE)));
  }

  protected void verifyDeleteAll() {<% item.entities.each { entity -> %>
    verify(controller.${entity.manager.names.instance}).deleteAll(false);<% } %>
  }

  @Test
  public void loadAll() {
    controller.loadAll();
    verifyLoadAll();
  }

  protected void verifyLoadAll() {<% item.entities.each { entity -> %>
    verify(controller.${entity.manager.names.instance}).findAll();<% } %><% item.entities.each { entity -> %>
    verify(controller.converter).convert${entity.names.clazz}sToExternal(${entity.names.instance}Ejbs);<% } %>
  }

  @Test
  public void loadInfoAll() {
    controller.loadInfoAll();
    verifyLoadInfoAll();
  }
  
  protected void verifyLoadInfoAll() {<% item.entities.each { entity -> %>
    verify(controller.${entity.manager.names.instance}).countAll();<% } %>
  }<% controller.refs.delegates.each { opRef-> def ref = opRef.reference(); def op = ref?.op; if(op) { def raw = op.rawType || (opRef.resultExpression && ref.el.multi && ref.el.typeRef.typeEntity) %>

  @Test
  public void ${opRef.nameTest}() {<% if(op.void) { %>
    controller.${opRef.nameExternal}($opRef.signatureTestValuesExternal);<% } else if(op.typeBoolean) { %>
    when(controller.${op.parent.names.instance}.${op.name}($opRef.signatureTestValuesExternal)).thenReturn(true);
    assertTrue(controller.${opRef.nameExternal}($opRef.signatureTestValuesExternal));<% } else { %>
    when(controller.${op.parent.names.instance}.${op.name}($opRef.signatureTestValuesExternal)).thenReturn(null);
    assertEquals(null, controller.${opRef.nameExternal}($opRef.signatureTestValuesExternal));<% } %>
    verify(controller.${op.parent.names.instance}).${op.name}($opRef.signatureTestValuesExternal);
  }<% } } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.container.containerControllerImpl = '''<% def controller = item.controller; if(controller && controller.base) { %><% def className = controller.names.impl %>
$macros.header
package ${destModule.namespace}. ${controller.namespace}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.Date;
import java.util.List;
import java.util.Map;
$controller.imports
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespace}. ${controller.namespace}.${controller.name};
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;

@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $controller.names.baseImpl {
  ${macros.apply(name: 'implOperations', item: controller)}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.container.event = '''${macros.apply('event')}'''

common.backend.container.containerEventReceiver = '''<% if(item.event) { %><% def className= "${item.names.event}Receiver" %>
$macros.header
package ${destModule.namespaces.integ}.receiver;

import static javax.enterprise.event.Reception.*;
import static javax.enterprise.event.TransactionPhase.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;

import com.siemens.ra.cg.pl.common.base.cdi.Receiver;
import ${destModule.namespace}.${item.namespace}.event.$item.names.event;

/** Event receiver for JSE environment only  of {@link $item.names.event} */
@ApplicationScoped
public class $className extends Receiver<${item.names.event}> {
  @Override
  public void onEvent(@Observes(during = AFTER_COMPLETION, notifyObserver = IF_EXISTS) $item.names.event event) {
    super.onEvent(event);
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/receiver/${className}.java" %><% } %>'''

common.backend.container.containerImpl = '''<% if(item.base) { %><% def className = item.names.impl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import ${destModule.namespace}.${item.namespace}.$item.name;
import ${destModule.namespace}.${item.namespace}.*;

public class $className extends $item.names.baseImpl {
  private static final long serialVersionUID = 1L;

  public $className() {
    super(false);
  }

  public $className(String source) {
    super(source, false);
  }

  public $className(boolean override) {
    super(override);
  }

  public $className(String source, boolean override) {
    super(source, override);
  }
  ${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.container.containerImportMdb = '''<% if(item.controller.asyncImport) { %><% def className = item.names.importMdb %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.messaging.EventListener;
import com.siemens.ra.cg.pl.common.ejb.messaging.SingleTypeEventListenerBridgeByJms;
import ${shared.namespaces.integ}.$module.shared.names.constants;
import ${destModule.namespace}.${item.namespace}.$item.capName;

/**
* The container import MDB is used to receive asynchronous import commands for container data.
*/
@MessageDriven(mappedName = ${module.shared.names.constants}.JMS_IMPORT_QUEUE,
               activationConfig = {
                   @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = ${module.shared.names.constants}.JMS_IMPORT_QUEUE),
                   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                   @ActivationConfigProperty(propertyName = "messageSelector", propertyValue = "datatype = '" + ${module.shared.names.constants}.JMS_MESSAGE_SELECTOR_${item.underscoredName} + "'")
               })
public class $className extends SingleTypeEventListenerBridgeByJms<${item.capName}> {

  @Inject  
  public void set${item.capName}Importer(EventListener<${item.capName}> listener) {
    super.setEventListener(listener);
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.backend.container.containerInfo = '''<% if(item.base) { %><% def className = item.names.info %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/**
* The container info is used to transfer bundled information about container data between between server and client.
* <p>
* ${item.description?item.description:''}
* </p>
*/
public interface $className extends $item.names.infoBase {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.container.containerInfoBase = '''<% def className = item.names.infoBase %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.io.Serializable;
import java.util.Date;
$item.imports

<% if(!item.base) { %>
/**
* The container info is used to transfer bundled information about container data between between server and client.
* <p>
* ${item.description?item.description:''}
* </p>
*/<% } else { %>/** Base interface of {@link $item.name} */<% } %>
public interface $className extends Serializable {

  /** Source of object builder. E.g. server/node name. */
  String getSource();
  void setSource(String source);

  /** Time point of data fetching */
  Date getTimestamp();

  void setTimestamp(Date timestamp);<% item.entities.each { entity -> %>

  long get${entity.names.clazz}sCount();

  void set${entity.names.clazz}sCount(long ${entity.names.instances}Count);<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.container.containerInfoBaseImpl = '''<% def className = item.names.infoBaseImpl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import java.util.Date;
import java.util.List;
import java.util.Map;$item.imports

import com.siemens.ra.cg.pl.common.base.model.Base;
import com.siemens.ra.cg.pl.common.base.util.StringUtils;
import com.siemens.ra.cg.pl.common.base.util.TimeUtils;

import ${destModule.namespace}.${item.namespace}.*;

public ${item.base?'abstract ':''}class $className extends Base implements $item.names.info {
  private static final long serialVersionUID = 1L;

  protected String source;
  protected Date timestamp;
  <% item.entities.each { entity -> %>
  protected long ${entity.names.instance}Count = 0;<% } %>

  public $className() {
    super();
    this.timestamp = TimeUtils.now();
  }

  public $className(String source) {
    this();
    this.source = source;
  }

  @Override
  public String getSource() {
    return source;
  }

  @Override
  public void setSource(String source) {
    this.source = source;
  }

  @Override
  public Date getTimestamp() {
    return timestamp;
  }

  @Override
  public void setTimestamp(Date timestamp) {
    this.timestamp = timestamp;
  }<% item.entities.each { entity -> %>

  @Override
  public long get${entity.names.clazz}sCount() {
    return ${entity.names.instance}Count;
  }

  @Override
  public void set${entity.names.clazz}sCount(long ${entity.names.instance}Count) {
    this.${entity.names.instance}Count = ${entity.names.instance}Count;
  }<% } %>

  @Override
  protected void fillToString(StringBuffer b) {
    super.fillToString(b);<% item.entities.each { entity -> def propName = "${entity.names.instance}Count" %>
    b.append("$propName=").append($propName).append(SEPARATOR);<% } %>
    b.append("timestamp=").append(StringUtils.formatDateLong(timestamp));
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();<% item.entities.each { entity -> def propAccess = "${entity.names.instance}Count" %>
    result = prime * result + (int) ($propAccess ^ ($propAccess >>> 32));<% } %>
    result = prime * result + ((timestamp == null) ? 0 : timestamp.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (!super.equals(obj))
      return false;
    if (getClass() != obj.getClass())
      return false;
    $className other = (${className}) obj;
    if (timestamp == null) {
      if (other.timestamp != null)
        return false;
    } else if (!timestamp.equals(other.timestamp))
      return false;<% item.entities.each { entity -> def propAccess = "${entity.names.instance}Count" %>
    if ($propAccess != other.$propAccess)
      return false;<% } %>
    return true;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %>'''

common.backend.container.containerInfoImpl = '''<% if(item.base) { %><% def className = item.names.infoImpl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import ${destModule.namespace}.${item.namespace}.$item.names.info;

public class $className extends $item.names.infoBaseImpl {
  private static final long serialVersionUID = 1L;

  public $className() {
    super();
  }

  public $className(String source) {
    super(source);
  }
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.all.controller.controllerImpl = '''<% if(item.base) { %><% def className = item.names.impl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.Date;
import java.util.List;
import java.util.Map;
$item.imports
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespace}.${item.namespace}.${item.name};
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;

@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $item.names.baseImpl {
  ${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.all.controller.controllerImplBase = '''<% def className = item.names.baseImpl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;<% def refs=item.refs.logicUnits %>
<% if(!item.base) { %>
import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;<% } %>

import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;
${macros.apply('importRefs')}
import ${destModule.namespace}.${item.namespace}.${item.name};
import ${destModule.namespaces.model}.*;<% if(module.entities) { %>
import ${destModule.namespaces.model}.ejb.*;<% } %>
import ${component.namespaces.integ}.$component.names.qualifier;

<% if(!item.base) { %>@Controller
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })<% } %>
public ${item.base?'abstract ':''}class $className implements $item.names.clazz {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  ${macros.apply('refsMembers')}
  ${macros.apply(name: 'implOperationsAndDelegates', override: true)}
  ${macros.apply('implInjects')}
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %>'''

common.all.controller.controllerInterface = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.${item.namespace};
$item.imports
/**
* The $item.name controller provides internal logic operations for '$module.name'.<% if(item.description) { %>
* <p>
* $item.description
* </p><% } %>
*/
public interface $className extends $item.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.all.controller.controllerInterfaceBase = '''<% def className = item.names.base %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.util.Date;
import java.util.List;
import java.util.Map;
$item.imports

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import ${destModule.namespaces.model}.*;<% if(module.entities) { %>
import ${destModule.namespaces.model}.ejb.*;<% } %>

<% if(!item.base) { %>
/**
* The controller $item.name provides internal logic operations for '$module.name'.<% if(item.description) { %>
* <p>
* $item.description
* </p><% } %>
*/<% } else { %>/** Base interface of {@link $item.name} */<% } %>
public interface $className {
  ${macros.apply('interfaceBody')}
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

jpa.backend.entity.beanBuilder = '''<% if (!item.virtual) { def className = "${item.names.beanBuilder}" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb.builder;

import ${destModule.namespace}.${item.namespace}.ejb.*;

public class $className extends ${item.names.beanBuilder}Base {
}
<% ret.overwrite = false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/ejb/builder/${className}.java" %><% } %>'''

common.backend.entity.builder = '''<% if (!item.virtual) { def className = "${item.names.builder}" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.builder;

import ${destModule.namespace}.${item.namespace}.*;

public class $className<T extends $item.names.clazz> extends ${item.names.builder}Base<T> {

  public $className(T instance) {
    super(instance);
  }
}
<% ret.overwrite = false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

common.backend.basicType.factory = '''<% if (!item.virtual) { def className = item.names.factory %>
${macros.apply(name: 'factory', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

common.backend.basicType.factoryBase = '''<% if (!item.virtual) { def className = "${item.names.factory}Base" %>
${macros.apply(name: 'factoryBase', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

entityImpl.backend.basicType.factoryImpl = '''<% if (!item.virtual) { def className = "${item.names.impl}Factory" %>
${macros.apply(name: 'factoryImpl', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/builder/${className}.java" %><% } %>'''

jpa.backend.basicType.factoryBean = '''<% if (!item.virtual) { def className = "${item.names.bean}Factory" %>
${macros.apply(name: 'factoryBean', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/ejb/builder/${className}.java" %><% } %>'''

common.backend.entity.factory = '''<% if (!item.virtual) { def className = item.names.factory %>
${macros.apply(name: 'factory', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

common.backend.entity.factoryBase = '''<% if (!item.virtual) { def className = "${item.names.factory}Base" %>
${macros.apply(name: 'factoryBase', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

entityImpl.backend.entity.factoryImpl = '''<% if (!item.virtual) { def className = "${item.names.impl}Factory" %>
${macros.apply(name: 'factoryImpl', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/builder/${className}.java" %><% } %>'''

jpa.backend.entity.factoryBean = '''<% if (!item.virtual) { def className = "${item.names.bean}Factory" %>
${macros.apply(name: 'factoryBean', className: className)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/ejb/builder/${className}.java" %><% } %>'''

common.backend.entity.builderBase = '''<% def className = "${item.names.builder}Base" %><% if (!item.virtual) { def idProp = item.idProp; def idGenerator; if(!item.manualId) {
  if(idProp.typeRef.typeLong) { idGenerator = 'AtomicLong' } else if (idProp.typeRef.typeInteger) { idGenerator = 'AtomicInteger' }; } %>
$macros.header
package ${destModule.namespace}.${item.namespace}.builder;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;<% if(idGenerator) { %>
import java.util.concurrent.atomic.$idGenerator;<% } %>
$item.imports
import com.siemens.ra.cg.pl.common.base.Builder;
import ${destModule.namespace}.${item.namespace}.*;

public abstract class $className<T extends $item.names.clazz> implements Builder<T> {<% if(idGenerator) { %>
  protected static final $idGenerator ID_GENERATOR = new $idGenerator();<% } %>

  private T instance;
  <% item.propsRecursive.each { prop-> if(!prop.relation) { if (idGenerator && prop.primaryKey) {%>
  protected $prop.computedType $prop.uncapName = ID_GENERATOR.incrementAndGet();<% } else { %>
  protected $prop.computedType $prop.uncapName = ${prop.testValue};<% }}} %>

  protected $className(T instance) {
    this.instance = instance;
  }

  @Override
  public T build() {
    <% item.propsRecursive.each { prop-> if(!prop.relation) { %>instance.$prop.setterCall;
    <% } } %>
    return instance;
  }<% item.propsRecursive.each { prop-> if(!prop.relation) { %>

  public $item.names.builder<T> with$prop.capName($prop.computedType $prop.uncapName) {
    this.$prop.uncapName = $prop.uncapName;
    return ($item.names.builder<T>) this;
  }<% } } %>
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/builder/${className}.java" %><% } %>'''

jpa.backend.entity.builderBaseEjb = '''<% if (!item.virtual) { def className = "${item.names.beanBuilder}Base" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb.builder;

import static com.siemens.ra.cg.pl.common.base.util.CollectionUtils.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
$item.imports
import com.siemens.ra.cg.pl.common.base.Builder;
import ${destModule.namespace}.${item.namespace}.*;
import ${destModule.namespace}.${item.namespace}.builder.*;
import ${destModule.namespace}.${item.namespace}.ejb.*;

public abstract class $className extends ${item.names.builder}<$item.names.bean> {
  <% item.propsRecursive.each { prop-> if(prop.typeEl && prop.manyToOne && !prop.typeEl.virtual) { %>
  protected $prop.computedTypeEjb $prop.name = new ${prop.typeEl.names.beanBuilder}().build();<% } else if (prop.relation) { %>
  protected $prop.computedTypeEjb $prop.name = ${prop.testValue};<% } } %>

  public $className() {
    super(new ${item.names.bean}());
  }

  @Override
  public $item.names.bean build() {
    $item.names.bean entity = super.build();
    <% item.propsRecursive.each { prop-> if(prop.relation) { %>entity.$prop.setterCall;
    <% } } %>
    return entity;
  }
  <% item.propsRecursive.each { prop-> if(prop.multi) { %>
  @SafeVarargs
  public final $item.names.beanBuilder with$prop.capName(Builder<$prop.relTypeEjb>... toAdd) {
    List<$prop.relTypeEjb> instances = new ArrayList<>();
    for (Builder<$prop.relTypeEjb> builder : toAdd) {
      instances.add(builder.build());
    }
    return with$prop.capName(instances);
  }

  public $item.names.beanBuilder with$prop.capName($prop.relTypeEjb... toAdd) {
    return with$prop.capName(asList(toAdd));
  }

  <% if (!prop.relation) { %>@Override<% } %>
  public $item.names.beanBuilder with$prop.capName($prop.computedTypeEjb toAdd) {
    this.${prop.name}.addAll(toAdd);
    return ($item.names.beanBuilder) this;
  }
  <% } else if (prop.relation) { %>
  public $item.names.beanBuilder with$prop.capName($prop.computedTypeEjb $prop.name) {
    this.${prop.name} = $prop.name;
    return ($item.names.beanBuilder) this;
  } 
  <% } else { %>
  @Override
  public $item.names.beanBuilder with$prop.capName($prop.computedType $prop.name) {
    return ($item.names.beanBuilder) super.with$prop.capName($prop.name);
  } 
  <% } } %>
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/ejb/builder/${className}.java" %><% } %>'''

entityImpl.backend.entity.builderBaseImpl = '''<% if (!item.virtual) { def className = "${item.names.implBuilder}Base" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl.builder;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import ${destModule.namespace}.${item.namespace}.*;
import ${destModule.namespace}.${item.namespace}.builder.*;
import ${destModule.namespace}.${item.namespace}.impl.*;
$item.imports

public abstract class $className extends ${item.names.builder}<$item.names.impl> {<% item.propsRecursive.each { prop-> if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne) ) { def relationIdProp = prop.typeEl.idProp %>
  
  protected $relationIdProp.computedType ${prop.name}Id<% if(!prop.typeEl.manualId) { %> = ID_GENERATOR.incrementAndGet()<% } %>;<% } } %>

  public $className() {
    super(new ${item.names.impl}());
  }
  
  @Override
  public $item.names.impl build() {
    $item.names.impl impl = super.build();
    <% item.propsRecursive.each { prop-> if(prop.manyToOne || prop.oneToOne) { %>impl.set${prop.capName}Id(${prop.name}Id);
    <% } } %>
    return impl;
  }<% item.propsRecursive.each { prop-> if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>
  
  public $item.names.implBuilder with${prop.capName}Id($relationIdProp.computedType ${prop.name}Id) {
    this.${prop.name}Id = ${prop.name}Id;
    return ($item.names.implBuilder) this;
  }<% } else if (!prop.relation) {  %>
  
  @Override
  public $item.names.implBuilder with$prop.capName($prop.computedType $prop.name) {
    return ($item.names.implBuilder) super.with$prop.capName($prop.name);
  }<% } } %>
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/builder/${className}.java" %><% } %>'''

entityImpl.backend.entity.implBuilder = '''<% if (!item.virtual) { def className = "${item.names.implBuilder}" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl.builder;

import ${destModule.namespace}.${item.namespace}.impl.*;

public class $className extends ${item.names.implBuilder}Base {
${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/impl/builder/${className}.java" %><% } %>'''

common.backend.entity.cacheBase =  '''<% def className = item.cache.names.base %>
$macros.header
package ${destModule.namespace}.${item.namespace}.cache;<% def superUnit = item.superUnit; def idProp = item.idProp; def manager = item.manager; def type = item.virtual?'E':item.names.clazz; def cacheSuper; 
  if(superUnit) { cacheSuper = "$superUnit.cache.names.clazz<$type>" } else { cacheSuper = "Cache<$idProp.type, $type>" }
  if(superUnit) { cacheSuper = "$superUnit.cache.names.clazz<$type>" } else if(idProp.typeRef.typeLong) { cacheSuper = "Cache<$idProp.type, $type>, TempIdCache" } else if(idProp.typeRef.typeInteger) { cacheSuper = "Cache<$idProp.type, $type>, TempIdCache" } else if(idProp.typeRef.typeString) { cacheSuper = "Cache<$idProp.type, $type>" } else { cacheSuper = "Cache<$idProp.type, $type>" }
%>
import static com.siemens.ra.cg.pl.common.base.util.ComparisonUtils.*;
$item.imports
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.siemens.ra.cg.pl.common.base.cache.Cache;
import com.siemens.ra.cg.pl.common.base.cache.TempIdCache;
import ${destModule.namespace}.${item.namespace}.*;

public interface <% if(item.virtual) { %>$className<E extends $item.names.clazz> extends $cacheSuper<% } else { %>$className extends $cacheSuper<% } %> {<% if(manager) { manager.finders.each { op-> if(!op.originalParent) { %>
  
  ${op.unique?"$type":"List<$type>"} ${op.name}($op.signature);<% } } } %><% item.props.each { prop-> if(prop.typeEl && prop.manyToOne) { def relationIdProp = prop.typeEl.idProp %>
  
  List<$type> findBy${prop.capName}${relationIdProp.capName}($relationIdProp.computedType ${prop.uncapName}${relationIdProp.capName});

  List<$type> findBy${prop.capName}${relationIdProp.capName}s(List<$relationIdProp.computedType> ${prop.uncapName}${relationIdProp.capName}s);<% } else if(prop.typeEl && prop.oneToOne) { def relationIdProp = prop.typeEl.idProp %>
  
  $type findBy${prop.capName}${relationIdProp.capName}($relationIdProp.computedType ${prop.uncapName}${relationIdProp.capName});<% } } %><% if(!superUnit) { %>
  
  List<$type> findNew();<% } %>
  ${macros.apply(name: 'interfaceBody', item: item.cache)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/${className}.java" %>'''

common.backend.entity.cacheTest = '''<% def className = item.cache.names.test %>
${macros.apply(name: 'cacheTest', className: className, override: false)}
<% ret.path = "${shared.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheOverrideTest = '''<% def className = item.cache.names.overrideTest %>
${macros.apply(name: 'cacheTest', className: className, override: true)}
<% ret.path = "${shared.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cache = '''<% def className = item.cache.names.clazz %>
$macros.header
package ${destModule.namespace}.${item.namespace}.cache;
$item.imports
import ${destModule.namespace}.${item.namespace}.*;

public interface <% if(item.virtual) { %>$className<E extends $item.names.clazz> extends ${item.cache.names.base}<E><% } else { %>$className extends ${item.cache.names.base}<% } %> {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/${className}.java" %>'''

common.backend.entity.cacheBaseImpl = '''<% def className = item.cache.names.baseImpl %>
${macros.apply(name: 'cacheBaseImpl', className: className, override: false)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheOverrideBase = '''<% def className = item.cache.names.overrideBase %>
${macros.apply(name: 'cacheBaseImpl', className: className, override: true)}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheTestBase = '''<% def className = item.cache.names.testBase %>
${macros.apply(name: 'cacheTestBase', className: className, override: false)}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheOverrideTestBase = '''<% def className = item.cache.names.overrideTestBase %>
${macros.apply(name: 'cacheTestBase', className: className, override: true)}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheImpl = '''<% def className = item.cache.names.impl %>
${macros.apply(name: 'cacheImpl', className: className, override: false)}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.cacheOverride = '''<% def className = item.cache.names.override %>
${macros.apply(name: 'cacheImpl', className: className, override: true)}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/cache/impl/${className}.java" %>'''

common.backend.entity.managerBaseTest = '''<% def manager = item.manager %><% if(manager && !item.virtual) { %><% def className = "${manager.names.base}TestImpl" %><% def idProp = item.idProp; def idConverter; 
   if (idProp.typeRef.typeLong) { idConverter = 'Integer.valueOf(entityNumber).longValue()' } else if (idProp.typeRef.typeInteger) { idConverter = 'Integer.valueOf(entityNumber)' } else { idConverter = 'String.valueOf(entityNumber)' }; %>
$macros.header
package ${destModule.namespace}.${manager.namespace};

import static org.hamcrest.CoreMatchers.*;
import static org.hamcrest.MatcherAssert.*;

import java.util.Date;
import java.util.List;

import javax.enterprise.inject.Alternative;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.ejb.core.ManagerTestBase;
import ${destModule.namespaces.model}.${item.names.clazz};
import ${destModule.namespaces.model}.event.${item.names.event};
import ${destModule.namespaces.model}.${module.names.dataFactory}Base;<% if(module.facet('jpa')) { %>
import ${destModule.namespaces.model}.ejb.${module.names.dataFactory}Ejb;
import ${destModule.namespaces.model}.ejb.${module.names.modelFactory}Ejb;<% } else if(module.facet('entityImpl')) { %>
import ${destModule.namespaces.model}.impl.${module.names.dataFactory}Impl;
import ${destModule.namespaces.model}.impl.${module.names.modelFactory}Impl;<% } %>

@Alternative
public abstract class $className extends ManagerTestBase<${item.idProp.type}, ${item.names.clazz}, ${manager.names.clazz}> {

  protected static ${module.names.dataFactory}Base dataFactory;
  
  @BeforeClass
  public static void before$className() {<% if(module.facet('jpa')) { %>
    dataFactory = new ${module.names.dataFactory}Ejb(new ${module.names.modelFactory}Ejb());<% } else if(module.facet('entityImpl')) { %>
    dataFactory = new ${module.names.dataFactory}Impl(new ${module.names.modelFactory}Impl());<% } %>
  }<% manager.counters.each { op-> %>

  @Test
  public void test${op.capName}() {
    manager.deleteAll();
    long count = manager.${op.capName}(${op.propGetters});
    assertThat(count, is(0));
    ${item.names.clazz} entity = manager.create(entityForCreation(1));
    count = manager.${op.capName}(${op.propGetters});
    assertThat(count, is(1));
  }<% } %><% manager.creators.each { op-> %>

  @Test
  public void test${op.capName}() {
    ${item.names.clazz} entity = entityForCreation(1);
    ${item.names.clazz} createdEntity = manager.${op.uncapName}(${op.propGetters});
    <% op.props.each { prop -> %>
    assertThat(createdEntity.get${prop.capName}(), is(entity.get${prop.capName}()));<% } %>
  }<% } %><% manager.deleters.each { op-> %>

  @Test
  public void test${op.capName}() {
    manager.deleteAll();
    ${item.names.clazz} entity = manager.create(entityForCreation(1));
    manager.${op.uncapName}(${op.propGetters});
    List<${item.names.clazz}> allEntities = manager.findAll();
    assertThat(allEntities.size(), is(0));
  }<% } %><% manager.existers.each { op-> %>

  @Test
  public void test${op.capName}() {
    manager.deleteAll();
    ${item.names.clazz} entity = entityForCreation(1);
    boolean exists = manager.${op.uncapName}(${op.propGetters});
    assertThat(exists, is(false));
    entity = manager.create(entity);
    exists = manager.${op.uncapName}(${op.propGetters});
    assertThat(exists, is(true));
  }<% } %><% manager.finders.each { op-> %>

  @Test
  public void test${op.capName}() {
    manager.deleteAll();
    $item.names.clazz entity = entityForCreation(1);
    $op.returnTypeExternal ret = manager.${op.uncapName}(${op.propGetters});<% if(op.unique) { %>
    assertThat(ret, nullValue());<% } else { %>
    assertThat(ret.size(), is(0));<% } %>
    entity = manager.create(entity);
    ret = manager.${op.uncapName}(${op.propGetters});<% if(op.unique) { %>
    assertThat(ret, notNullValue());<% } else { %>
    assertThat(ret.size(), is(1));<% } %>
  }<% } %>

  @Override
  protected ${item.idProp.type} sampleEntityId(int entityNumber) {
    return $idConverter;
  }

  @Override
  protected $item.names.clazz entityForCreation(int entityNumber) {
    ${item.names.clazz} ret = dataFactory.new${item.capName}(entityNumber);
    return ret;
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.backend.entity.managerImpl = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager %><% if(manager.base) { %><% def className= manager.names.impl %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.impl;
$manager.imports
import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.List;
import java.util.Date;
import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.annotations.Manager;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespace}.${manager.namespace}.$manager.name;
import ${destModule.namespace}.${item.namespace}.ejb.*;
import ${destModule.namespace}.${item.namespace}.*;

/** JPA implementation of {@link $manager.name} */
@Manager
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL }, runtimes = { CLIENT }) })
public class $className extends $manager.names.baseImpl {
  ${macros.apply(name: 'implOperations', item: manager)}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/impl/${className}.java" %><% } %><% } %>'''

jpa.backend.entity.managerImplBase = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager; def className= manager.names.baseImpl; def idProp = item.idProp; def refs=manager.refs.logicUnits %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.impl;
${manager.base?'':' import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*; import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;'}
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;
import javax.persistence.EntityManager;${manager.base?' import javax.enterprise.inject.Alternative;':' import com.siemens.ra.cg.pl.common.base.annotations.Manager;'}
import javax.enterprise.event.Event;

import ${destModule.namespace}.${item.namespace}.builder.$item.names.factory;
import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.annotations.Backend;${manager.base?'':' import com.siemens.ra.cg.pl.common.base.cdi.env.Environment; import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments; '}
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import com.siemens.ra.cg.pl.common.base.model.StringLink;
import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.ejb.core.ManagerAbstract;
${macros.apply(name: 'importRefs', item: manager)}
import ${destModule.namespace}.${manager.namespace}.${item.manager.name};
import ${shared.namespaces.integ}.${shared.names.ml};

import ${destModule.namespace}.${item.namespace}.event.${item.names.event};
import ${component.shared.namespaces.integ}.${component.names.qualifier};
import ${destModule.namespace}.${item.namespace}.ejb.*;
import ${destModule.namespace}.${item.namespace}.*;
/** JPA implementation of {@link $manager.name} */
<% if(manager.base) { %>@Alternative<% }else { %>@Manager
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL }, runtimes = { CLIENT }) })<% } %>
public ${manager.base?'abstract ':''}class $className extends ManagerAbstract<${idProp.type}, $item.names.clazz> implements $manager.name {
  protected Event<${item.names.event}> publisher;<% refs.each { ref-> %>
  
  protected $ref.names.clazz $ref.names.instance;<% } %><% manager.counters.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    Long ret = findValueByUniqueProperties(${item.names.bean}.$op.underscoredName, $op.propLinks);
    return ret.longValue();
  }<% } %><% manager.creators.each { op-> %>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $item.names.clazz ret = factory.newInstance();<% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = create(ret);
    return ret;
  }<% } %><% manager.deleters.each { op-> %>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($op.signature) {
    executeByProperties(${item.names.bean}.$op.underscoredName, $op.propLinks);
  }<% } %><% manager.existers.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    Long ret = findValueByUniqueProperties(${item.names.bean}.$op.underscoredName, $op.propLinks);
    return ret > 0;
  }<% } %><% manager.finders.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.returnTypeExternal ret = findBy${op.unique?'Unique':''}Properties(${item.names.bean}.$op.underscoredName, $op.propLinks);
    return ret;
  }<% } %><% manager.operationsNotManager.each { op-> if(op.body) { %>

  @Override<% if(op.transactional) { %>
  @Transactional<% } %><% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } } %><% manager.updators.each { op->
    def retPropGetters = op.propAttrs.collect { "ret.$it.prop.getter" }.join(', ')
    def propNames = op.propAttrs.collect { it.prop.name }.join(', ') %>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature) {
    return ${op.name}(findById(${idProp.name}), $op.signatureNames);
  }<%if(op.fireEventProp){%>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature, boolean fireEvent) {
    return ${op.name}(findById(${idProp.name}), $op.signatureNames, fireEvent);
  }

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature) {
    return ${op.name}(entity, $op.signatureNames, true);
  }

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature, boolean fireEvent) {
    $item.names.clazz ret = entity;
    //build ml key parameter
    Object[] mlParameters = new Object[] { ret.$idProp.getter, ret.getNaturalKey(), $retPropGetters, $propNames };

    //update properties
    <% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = merge(ret);
    
    //send ml event
    if (fireEvent){
        forceVersionUpdate();
        $item.names.event event = new $item.names.event(ret, ActionType.UPDATE, source);
        event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.$op.names.mlKeyConstant, mlParameters);
        fireEvent(event);
    }

    return ret;
  }
  <%} else {%>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature) {
    $item.names.clazz ret = entity;
    //build ml key parameter
    Object[] mlParameters = new Object[] { ret.$idProp.getter, ret.getNaturalKey(), $retPropGetters, $propNames };

    //update properties<% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = merge(ret);

    //send ml event
    forceVersionUpdate();
    $item.names.event event = new $item.names.event(ret, ActionType.UPDATE, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.$op.names.mlKeyConstant, mlParameters);
    fireEvent(event);

    return ret;
  }
  <%}%>
  <% } %><% if(item.ordered) { def orderProp = item.resolveProp('order'); %>
  
  @Override
  @Transactional
  public List<$item.names.clazz> createAll(List<$item.names.clazz> entities, boolean fireEvent) {
    fillOrder(entities, 1);
    return super.createAll(entities, fireEvent);
  }

  protected void fillOrder(List<$item.names.clazz> entities, long startOrder) {
    long order = startOrder;
    for($item.names.clazz entity : entities) {
      if(entity.${orderProp.getter} == null) {
        entity.set${orderProp.capName}(order++);
      }
    }
  }<% } %>

  @Override
  public void fireEvent($item.names.clazz entity, ActionType actionType) {
    forceVersionUpdate();   
    $item.names.event event = new ${item.names.event}(entity, actionType, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, buildMlKey(${shared.names.ml}.$item.names.mlKeyConstant, actionType), entity.$idProp.getter, entity.getNaturalKey() );
    fireEvent(event);
  }

  @Override
  public void fireEvent(ActionType actionType) {
    $item.names.event event = new ${item.names.event}(actionType, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, buildMlKey(${shared.names.ml}.$item.names.mlKeyConstant, actionType));
    fireEvent(event);
  }

  protected void fireEvent(${item.names.event} event) {
    publisher.fire(event);
  }

  @Override
  @Inject
  public void setEntityManager(@$component.names.qualifier EntityManager entityManager) {
    this.entityManager = entityManager;
  }

  @Inject
  public void setFactory($item.names.factory factory) {
    super.setFactory(factory);
  }

  @Inject
  public void setPublisher(@$component.names.qualifier @Backend Event<${item.names.event}> publisher) {
    this.publisher = publisher;
  }<% refs.each { ref-> def uncapName = ref.name.uncapitalize() %>

  @Inject
  public void set${ref.name}($ref.name $uncapName) {
    this.$uncapName = $uncapName;
  }<% } %>

  @Override
  public Class<? extends $item.names.clazz> findEntityClass() {
    return ${item.names.bean}.class;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

common.backend.entity.manager = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager %><% if(manager.base) { %><% def className= manager.names.clazz %>
$macros.header
package ${destModule.namespace}.$manager.namespace;

import ${destModule.namespace}.${item.namespace}.${item.names.clazz};
import ${destModule.namespace}.${manager.namespace}.$manager.names.base;

<% if(manager.description) { %>/**
* $manager.description
*/<% } else { %>/** The manager provides CRUD operations for entity {@link $item.names.clazz} */<% } %>
public interface $className extends $manager.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/${className}.java" %><% } %><% } %>'''

common.backend.entity.managerBase = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager %><% def className= manager.names.base; def idProp = item.idProp; %>
$macros.header
package ${destModule.namespace}.$manager.namespace;
$manager.imports
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.ejb.core.Manager;
import ${destModule.namespace}.${item.namespace}.${item.names.clazz};
import ${destModule.namespace}.${item.namespace}.*;

<% if(manager.description) { %>/**
* $manager.description
*/<% } else { %>/** The manager provides CRUD operations for entity {@link $item.names.clazz}.*/<% } %>
public interface $className extends Manager<${idProp.type}, $item.names.clazz> { <% manager.counters.each { op-> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.creators.each { op-> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.deleters.each { op-> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.existers.each { op-> %>
  ${op.description?"   /** $exister.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.finders.each { op-> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.operationsNotManager.each { op -> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($op.signature);<% } %><% manager.updators.each { op-> %>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature);
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature);
  <%if(op.fireEventProp){%>
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature, boolean fireEvent);
  ${op.description?"   /** $op.description */":''}
  $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature, boolean fireEvent);

<% }} %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.backend.entity.managerLocalTest = '''<% def manager = item.manager %><% if(manager && !item.virtual) { %><% def className = "${manager.names.clazz}LocalTest" %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.impl;

import javax.enterprise.event.Event;
import javax.enterprise.inject.Alternative;

import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.siemens.ra.cg.pl.common.base.integ.SingletonContainer;
import ${destModule.namespaces.integ}.jse.${module.names.managerFactory}Local;
import ${destModule.namespaces.core}.${manager.name}TestImpl;

@Alternative
public class $className extends ${manager.name}TestImpl {
 
  @BeforeClass
  @SuppressWarnings({ "rawtypes", "unchecked" })  
  public static void before$className() {
    ${module.names.managerFactory}Local managerFactory = SingletonContainer.getSingleton(${module.names.managerFactory}Local.class);
    preparedManager = managerFactory.get${manager.capName}((Event)publisher);
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/impl/${className}.java" %><% } %>'''

memory.backend.entity.managerMem = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager %><% if(manager.base) { %><% def className= manager.names.mem %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.mem;
import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;

import javax.enterprise.context.ApplicationScoped;

import java.util.Date;
import java.util.List;
$item.imports
import com.siemens.ra.cg.pl.common.base.annotations.Manager;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespace}.${manager.namespace}.$manager.name;
import ${destModule.namespace}.${item.namespace}.*;

/** Memory implementation of {@link $manager.name} */
@ApplicationScoped
@Manager
@SupportsEnvironments(@Environment(executions = { MEMORY }))
public class $className extends $manager.names.baseMem {
  ${macros.apply(name: 'implOperations', item: manager)}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/mem/${className}.java" %><% } %><% } %>'''

memory.backend.entity.managerMemBase = '''<% if(item.manager && !item.virtual) { %><% def manager = item.manager; def className= manager.names.baseMem; def idProp = item.idProp; %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.mem;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.util.ComparisonUtils.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Event;
import javax.inject.Inject;
import javax.enterprise.inject.Alternative;
$manager.imports
import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import ${destModule.namespace}.${item.namespace}.builder.$item.names.factory;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.annotations.Manager;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import com.siemens.ra.cg.pl.common.base.model.StringLink;
import com.siemens.ra.cg.pl.common.ejb.core.mem.ManagerMemAbstract;
import ${destModule.namespace}.${manager.namespace}.${item.manager.name};
import ${shared.namespaces.integ}.${shared.names.ml};

import ${destModule.namespace}.${item.namespace}.event.${item.names.event};
import ${component.shared.namespaces.integ}.${component.names.qualifier};
import ${destModule.namespace}.${item.namespace}.*;

/** Memory implementation of {@link $manager.name} */
<% if(manager.base) { %>@Alternative<% }else { %>@ApplicationScoped
@Manager
@SupportsEnvironments(@Environment(executions = { MEMORY }))<% } %>
public ${manager.base?'abstract ':''}class $className extends ManagerMemAbstract<${idProp.type}, $item.names.clazz> implements $manager.name {
  protected Event<${item.names.event}> publisher;<% manager.counters.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.returnTypeExternal ret = 0;
    for ($op.entity.names.clazz entity : findAll()) {
      if (${op.propCompare}) {
        ret++;
      }
    }
    return ret;
  }<% } %><% manager.creators.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $item.names.clazz ret = factory.newInstance();<% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = create(ret);
    return ret;
  }<% } %><% manager.deleters.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    ArrayList<$op.entity.names.clazz> toDelete = new ArrayList<>();
    for ($op.entity.names.clazz entity : findAll()) {
      if (${op.propCompare}) {
        toDelete.add(entity);
      }
    }
    if(!toDelete.isEmpty()){
      removeAll(toDelete);
      fireEvent(ActionType.DELETE_MULTIPLE);
    }
  }<% } %><% manager.existers.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    boolean ret = false;
    for ($op.entity.names.clazz entity : findAll()) {
      if (${op.propCompare}) {
        ret = true;
        break;
      }
    }
    return ret;
  }<% } %><% manager.finders.each { op-> %>

  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.returnTypeExternal ret = ${op.unique?null:"new ArrayList<>()"};
    for ($op.entity.names.clazz entity : findAll()) {
      if (${op.propCompare}) {<% if(op.unique) { %>
        ret = entity;
        break;<% } else { %>
        ret.add(entity);<% } %>
      }
    }
    return ret;
  }<% } %><% manager.operationsNotManager.each { op-> if(op.body) { %>

  @Override<% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } } %><% manager.updators.each { op->
    def retPropGetters = op.propAttrs.collect { "ret.$it.prop.getter" }.join(', ')
    def propNames = op.propAttrs.collect { it.prop.name }.join(', ') %>

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature) {
    return ${op.name}(findById(${idProp.name}), $op.signatureNames);
  }

  <%if (op.fireEventProp) {%>
  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($idProp.computedType $idProp.name, $op.signature, boolean fireEvent) {
    return ${op.name}(findById(${idProp.name}), $op.signatureNames, fireEvent);
  }

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature) {
    return ${op.name}(entity, $op.signatureNames, true);
  }

  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature, boolean fireEvent) {
    $item.names.clazz ret = entity;
    //build ml key parameter
    Object[] mlParameters = new Object[] { ret.$idProp.getter, ret.getNaturalKey(), $retPropGetters, $propNames };

    //update properties<% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = merge(ret);

    //send ml event
    if (fireEvent) {
      forceVersionUpdate();
      $item.names.event event = new $item.names.event(ret, ActionType.UPDATE, source);
      event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.$op.names.mlKeyConstant, mlParameters);
      publisher.fire(event);
    }

    return ret;
  }
  <%} else {%>
  @Override
  @Transactional
  public $op.returnTypeExternal ${op.name}($item.names.clazz entity, $op.signature) {
    $item.names.clazz ret = entity;
    //build ml key parameter
    Object[] mlParameters = new Object[] { ret.$idProp.getter, ret.getNaturalKey(), $retPropGetters, $propNames };

    //update properties<% op.propAttrs.each { def propAttr-> def prop = propAttr.prop; if(propAttr.defaultValue) { %>
    ret.set$prop.capName($propAttr.defaultValue);<% } else { %>
    ret.set$prop.capName($prop.name);<% } } %>
    ret = merge(ret);

    //send ml event
    forceVersionUpdate();
    $item.names.event event = new $item.names.event(ret, ActionType.UPDATE, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, ${shared.names.ml}.$op.names.mlKeyConstant, mlParameters);
    publisher.fire(event);

    return ret;
  }
  <%}%>
  <% } %><% if(item.ordered) { def orderProp = item.resolveProp('order'); %>
  
  @Override
  @Transactional
  public List<$item.names.clazz> createAll(List<$item.names.clazz> entities, boolean fireEvent) {
    fillOrder(entities, 1);
    return super.createAll(entities, fireEvent);
  }

  protected void fillOrder(List<$item.names.clazz> entities, long startOrder) {
    long order = startOrder;
    for($item.names.clazz entity : entities) {
      if(entity.${orderProp.getter} == null) {
        entity.set${orderProp.capName}(order++);
      }
    }
  }<% } %>

  @Override
  protected void beforePersist($item.names.clazz entity) {
    ${idProp.computedTypeEjb} id = generateId(entity);
    if(id!=null){
      entity.set${idProp.capName}(id);
    }
  }

  @Override
  public void fireEvent($item.names.clazz entity, ActionType actionType) {
    forceVersionUpdate();
    $item.names.event event = new ${item.names.event}(entity, actionType, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, buildMlKey(${shared.names.ml}.$item.names.mlKeyConstant, actionType), entity.$idProp.getter, entity.getNaturalKey() );
    fireEvent(event);
  }

  @Override
  public void fireEvent(ActionType actionType) {
    $item.names.event event = new ${item.names.event}(actionType, source);
    event.initMlKey(${shared.names.ml}.ML_BASE, buildMlKey(${shared.names.ml}.$item.names.mlKeyConstant, actionType));
    fireEvent(event);
  }

  protected void fireEvent(${item.names.event} event) {
    publisher.fire(event);
  }

  @Inject
  public void setPublisher(@$component.names.qualifier @Backend Event<${item.names.event}> publisher) {
    this.publisher = publisher;
  }

  @Inject
  public void setFactory($item.names.factory factory) {
    super.setFactory(factory);
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/mem/${className}.java" %><% } %>'''

memory.backend.entity.managerMemoryTest = '''<% def manager = item.manager %><% if(manager && !item.virtual) { %><% def className = "${manager.names.clazz}MemoryTest" %>
$macros.header
package ${destModule.namespace}.${manager.namespace}.mem;

import javax.enterprise.event.Event;
import javax.enterprise.inject.Alternative;

import java.util.Date;

import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.siemens.ra.cg.pl.common.base.integ.SingletonContainer;
import ${destModule.namespaces.integ}.mem.${module.names.managerFactory}Memory;
import ${destModule.namespaces.core}.${manager.name}TestImpl;

@Alternative
public class $className extends ${manager.name}TestImpl {
  
  @BeforeClass
  @SuppressWarnings({ "rawtypes", "unchecked" })  
  public static void before$className() {
    ${module.names.managerFactory}Memory managerFactory = SingletonContainer.getSingleton(${module.names.managerFactory}Memory.class);
    preparedManager = managerFactory.get${manager.capName}((Event)publisher);
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/mem/${className}.java" %><% } %>'''

common.backend.entity.managerTest = '''<% def manager = item.manager %><% if(manager && manager.base && !item.virtual) { %><% def className = "${manager.names.clazz}TestImpl" %>
$macros.header
package ${destModule.namespace}.${manager.namespace};

import javax.enterprise.inject.Alternative;

@Alternative
public abstract class $className extends ${manager.names.base}TestImpl {
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${manager.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

jpa.backend.entity.bean = '''<% if(item.base) { def className = item.names.bean; %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;

import javax.persistence.Entity;
import javax.persistence.MappedSuperclass;

import ${destModule.namespace}.${item.namespace}.${item.names.clazz};

${item.virtual?'@MappedSuperclass':'@Entity'}
public ${item.virtual?'abstract ':''}class $className extends $item.names.baseBean {
  private static final long serialVersionUID = 1L;
  ${macros.apply(name: 'constructorsSuper', className: className)}
  ${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${item.names.bean}.java" %><% } %>'''

jpa.backend.entity.baseBean = '''<% def className = item.names.baseBean %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;<% def superUnit = item.superUnit; def props = item.props.findAll{!it.primaryKey}; def idProp = item.idProp; %>
$item.imports
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.MappedSuperclass;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.Index;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.OneToOne;
import javax.persistence.ManyToOne;
import javax.persistence.ManyToMany;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

${!superUnit?'import com.siemens.ra.cg.pl.common.ejb.model.BaseEntityImpl;':''}

import ${destModule.namespace}.${item.namespace}.*;
<% def manager = item.manager %>
${(item.base||item.virtual)?'@MappedSuperclass':'@Entity'}<% if(!item.virtual) { %>
${manager?manager.toNamedQueries():''}
$item.mapping<% } %>
public ${ item.virtual || item.base ?'abstract ':''}class $className extends <% if(superUnit) { %>$superUnit.names.bean<% }else { %>BaseEntityImpl<${idProp.type}><% } %> implements ${item.name} {
  private static final long serialVersionUID = 1L;
  ${macros.apply('entitySqlTableConstant')}
  ${macros.apply('propsSqlConstants')}
  <% def commands = (manager && !item.virtual)?manager.commands():[]; commands.each { command-> %>
  public static final String $command.underscoredName = "${item.sqlName}.$command.underscoredName";<% } %>
  <% if(!item.virtual) { if(!item.manualId) { def generator = "${module.capShortName.toUpperCase()}_${item.sqlName}_SEQ" %>
  @GeneratedValue(strategy = GenerationType.TABLE, generator = "$generator")
  @TableGenerator(name = "$generator", table = "SEQUENCER")<% } %>
  @Id  
  protected $idProp.computedTypeEjb $idProp.name;
  <% } %><% item.multiSuperProps.each { prop-> def mapping = prop.buildMapping(item); if(mapping) { %>
  $mapping<% } %>
  protected $prop.computedTypeEjbMember $prop.name$prop.defaultNotation;
  <% } %><% props.each { prop-> if(!item.virtual || (item.virtual && !prop.multi)) { def mapping = prop.mapping; if(mapping) { %>
  $mapping<% } %>
  protected $prop.computedTypeEjbMember $prop.name$prop.defaultNotation;
  <% } } %>
  ${macros.apply(name: 'constructors', className: className)}<% if(!item.virtual) { %>
  @Override
  public $idProp.computedTypeEjb $idProp.getter {
    return $idProp.name;
  }

  @Override
  public void set${idProp.capName}($idProp.computedTypeEjb $idProp.name) {
    this.$idProp.name = $idProp.name;
  }<% } %><% item.multiSuperProps.each { prop-> %>
  
  @Override<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $prop.computedTypeEjb $prop.getter {<% if(prop.multi) { %>
    if($prop.name == null) {
      $prop.name = new ArrayList<>();
    }<% } %>
    return <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } %>$prop.name;
  }<% if(!(prop.multi && prop.oppositeProp)) { %>
  
  @Override<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public void set${prop.capName}($prop.computedTypeEjb $prop.name) {
    this.$prop.name = <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } else if(prop.typeRef.typeBasicType) { %>($prop.computedTypeEjbMember)<% } %>$prop.name;
  }<% } else { %>
  
  @Override
  public void set${prop.capName}($prop.computedTypeEjb $prop.name) {
    this.$prop.name = $prop.name;
    if($prop.name != null) {
      for ($prop.relTypeEjb child : $prop.name) {
        child.set$prop.oppositeProp.capName(${item.base ? "($item.names.bean)" : ''}this);
      }
    }
  }<% } } %><% props.each { prop-> if(!item.virtual || (item.virtual && !prop.elementCollection)) { %>
  ${!prop.relation?'@Override':''}<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %><% if(item.virtual && prop.multi) { %>
  public abstract $prop.computedTypeEjb $prop.getter;<% } else { %>
  public $prop.computedTypeEjb $prop.getter {<% if(prop.multi) { %>
    if($prop.name == null) {
      $prop.name = new ArrayList<>();
    }<% } %>
    return <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } %>$prop.name;
  }<% } %><% if(item.virtual && prop.multi) { %>
  
  public abstract void set${prop.capName}($prop.computedTypeEjb $prop.name);<% } else if(!(prop.multi && prop.oppositeProp)) { %>
  ${!prop.relation?'@Override':''}<% if(prop.multi && prop.typeRef.typeBasicType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public void set${prop.capName}($prop.computedTypeEjb $prop.name) {
    this.$prop.name = <% if(prop.multi && prop.typeRef.typeBasicType) { %>(List)<% } else if(prop.typeRef.typeBasicType) { %>($prop.computedTypeEjbMember)<% } %>$prop.name;
  }<% } else { %>
  
  public void set${prop.capName}($prop.computedTypeEjb $prop.name) {
    this.$prop.name = $prop.name;<% if(prop.typeEl.ordered || !prop.oppositeProp.multi) { %>
    if($prop.name != null) {<% if(prop.typeEl.ordered) { %>
      long order = 1;
      for ($prop.relTypeEjb child : $prop.name) {
        child.setOrder(order++);<% if(!prop.oppositeProp.multi) { %>
        child.set$prop.oppositeProp.capName(${item.base ? "($item.names.bean)" : ''}this);<% } %>
      }<% } else if(!prop.oppositeProp.multi) { %>
      for ($prop.relTypeEjb child : $prop.name) {
        child.set$prop.oppositeProp.capName(${item.base ? "($item.names.bean)" : ''}this);
      }<% } %>
    }<% } %>
  }<% } %><% if(prop.multi && prop.oppositeProp) { %>
  
  public boolean addTo${prop.capName}($prop.relTypeEjb child) {<% if(!prop.oppositeProp.multi) { %>
    child.set$prop.oppositeProp.capName(${item.base ? "($item.names.bean)" : ''}this);<% } else { %>
    child.get$prop.oppositeProp.capName().add(${item.base ? "($item.names.bean)" : ''}this);<% } %><% if(prop.typeEl.ordered) { %>
    child.setOrder(Long.valueOf(${prop.getter}.size() + 1));
    <% } %>
    return ${prop.getter}.add(child);
  }

  public boolean removeFrom${prop.capName}($prop.relTypeEjb child) {<% if(!prop.oppositeProp.multi) { %>
    child.set$prop.oppositeProp.capName(null);<% } else { %>
    child.get$prop.oppositeProp.capName().remove(${item.base ? "($item.names.bean)" : ''}this);<% } %>
    return ${prop.getter}.remove(child);
  }<% } } } %><% item.props.each { prop-> if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>

  @Override
  public $relationIdProp.computedType get${prop.capName}${relationIdProp.capName}() {
    return ${prop.uncapName} !=null ? ${prop.uncapName}.get${relationIdProp.capName}() : null;
  }

  @Override
  public void set${prop.capName}${relationIdProp.capName}($relationIdProp.computedTypeEjb ${prop.name}${relationIdProp.capName}) {
    //nothing, because object based;
  }<% } } %><% if(item.labelBody) { %>

  @Override
  public String getNaturalKey() {
    return $item.labelBody;
  }<% } %><% item.operations.each { op-> if(op.body) { %>
  <% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } } %>

  @Override
  protected void fillToString(StringBuffer b) {
    super.fillToString(b);<% if(!item.virtual) { %>
    b.append("$idProp.name=").append($idProp.name).append(SEPARATOR);<% } %><% props.each { prop-> if(!prop.relation && prop.type.matches('(String|Boolean|Long|Integer)')) { %>
    b.append("$prop.name=").append($prop.name).append(SEPARATOR);<% } } %>
  }
  ${macros.apply(name: 'hashCodeAndEqualsEntity', className: className)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

jpa.backend.entity.beanTest = '''<% def className; if(item.virtual) { className = "${item.names.bean}TestAbstract" } else { className = "${item.names.bean}Test" }; def multiProp = item.props.find { it.multi } %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;

import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;
import static org.hamcrest.MatcherAssert.*;

import com.siemens.ra.cg.pl.common.base.util.TimeUtils;

import java.util.Collections;
import java.util.Date;

import org.junit.Test;<% if(item.superUnit) { %>

public ${item.virtual ? 'abstract ' : ''}class $className extends ${item.superUnit.names.bean}TestAbstract { <% } else { %>

public ${item.virtual ? 'abstract ' : ''}class $className { <% } %>

  <% if(multiProp) { %>@SuppressWarnings("unchecked")<% } %><% if(item.virtual) { %>
  public void testGetterSetetrsOf${item.capName}(${item.names.bean} entity) {<% } else { %>
  @Test
  public void testGetterSetetrsOf${item.capName}() {
    ${item.names.bean} entity = new ${item.names.bean}();<% } %><% if(item.superUnit) { %>
    super.testGetterSetetrsOf${item.superUnit.capName}(entity);<% } %><% item.props.each { prop -> if(!prop.multi) {  if (prop.type == 'String') { %>
    entity.set${prop.capName}("$prop.capName");
    assertThat(entity.${prop.getter}, is("$prop.capName"));<% } else if (prop.type == 'Long') { %>
    entity.set${prop.capName}(Long.valueOf(1));
    assertThat(entity.${prop.getter}, is(Long.valueOf(1)));<% } else if (prop.type == 'Integer') { %>
    entity.set${prop.capName}(Integer.valueOf(1));
    assertThat(entity.${prop.getter}, is(Integer.valueOf(1)));<% } else if (prop.type == 'Date') { %>
    Date $prop.uncapName = TimeUtils.now();
    entity.set${prop.capName}($prop.uncapName);
    assertThat(entity.${prop.getter}, is($prop.uncapName));<% } else { %>
    entity.set${prop.capName}(null);
    assertThat(entity.${prop.getter}, is(nullValue()));<% } %><% } else { %>
    entity.set${prop.capName}(Collections.EMPTY_LIST);
    assertThat(entity.${prop.getter}.isEmpty(), is(true));<% } %><% } %>
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.entity.event = '''${macros.apply('event')}'''

common.backend.entity.eventReceiver = '''<% if(item.event) { %><% def className= "${item.names.event}Receiver" %>
$macros.header
package ${destModule.namespaces.integ}.receiver;

import static javax.enterprise.event.Reception.*;
import static javax.enterprise.event.TransactionPhase.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;

import com.siemens.ra.cg.pl.common.base.cdi.Receiver;
import ${destModule.namespace}.${item.namespace}.event.$item.names.event;

/** Event receiver for JSE environment only  of {@link $item.names.event} */
@ApplicationScoped
public class $className extends Receiver<${item.names.event}> {
  @Override
  public void onEvent(@Observes(during = AFTER_COMPLETION, notifyObserver = IF_EXISTS) $item.names.event event) {
    super.onEvent(event);
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/receiver/${className}.java" %><% } %>'''

entityImpl.backend.entity.impl = '''<% if(item.base) { %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import ${destModule.namespace}.${item.namespace}.${item.names.clazz};

public ${item.virtual?'abstract ':''}class $item.names.impl extends $item.names.baseImpl {
  private static final long serialVersionUID = 1L;
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${item.names.impl}.java" %><% } %>'''

entityImpl.backend.entity.baseImpl = '''<% def className = item.names.baseImpl %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;<% def superUnit = item.superUnit; def props = item.props.findAll{!it.primaryKey}; def idProp = item.idProp; %>
$item.imports
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

${!superUnit?'import com.siemens.ra.cg.pl.common.ejb.model.BaseEntityImpl;':''}

import ${destModule.namespace}.${item.namespace}.*;

public ${item.virtual || item.base ? 'abstract ' : ''}class $className extends <% if(superUnit) { %>$superUnit.names.impl<% }else { %>BaseEntityImpl<${idProp.type}><% } %> implements ${item.name} {
  private static final long serialVersionUID = 1L;<% item.props.each { prop-> if(!prop.relation) { %>
  protected $prop.computedType $prop.name;<% } else if (prop.typeEl &&  (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>
  protected $relationIdProp.computedType ${prop.name}${relationIdProp.capName};<% } } %><% item.props.each { prop-> if (!prop.relation) { %>

  @Override
  public $prop.computedTypeEjb $prop.getter {
    return $prop.name;
  }

  @Override
  public void set${prop.capName}($prop.computedTypeEjb $prop.name) {
    this.$prop.name = $prop.name;
  }<% } else if (prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>

  @Override
  public $relationIdProp.computedTypeEjb get${prop.capName}${relationIdProp.capName}() {
    return ${prop.name}${relationIdProp.capName};
  }

  @Override
  public void set${prop.capName}${relationIdProp.capName}($relationIdProp.computedTypeEjb ${prop.name}${relationIdProp.capName}) {
    this.${prop.name}${relationIdProp.capName} = ${prop.name}${relationIdProp.capName};
  }<% } } %><% item.operations.each { op-> if(op.body) { %>
  <% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  @Override
  public $op.returnTypeExternal ${op.name}($op.signature) {
    $op.body
  }<% } } %>

  @Override
  protected void fillToString(StringBuffer b) {
    super.fillToString(b);<% if(!item.virtual) { %>
    b.append("$idProp.name=").append($idProp.name).append(SEPARATOR);<% } %><% props.each { prop-> if(!prop.relation && prop.type.matches('(String|Boolean|Long|Integer)')) { %>
    b.append("$prop.name=").append($prop.name).append(SEPARATOR);<% } } %>
  }
  ${macros.apply(name: 'hashCodeAndEqualsEntity', className: className)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${item.names.baseImpl}.java" %>'''

common.backend.entity.clazz = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.$item.namespace;
$item.imports

/** Base interface for {@link $item.names.base} */
public interface $className extends $item.names.base {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.entity.base = '''<% def className = item.names.base %>
$macros.header
package ${destModule.namespace}.$item.namespace;<% def superUnit = item.superUnit %>

import java.util.Date;
import java.util.List;
import java.util.Map;$item.imports
import com.siemens.ra.cg.pl.common.base.model.BaseEntity;
import com.siemens.ra.cg.pl.common.base.model.IdSetter;

${item.description?"/*** $item.description */":''}
public interface $className extends <% if(superUnit) { %>$superUnit.name<% }else { %>BaseEntity<${item.idProp.type}>, IdSetter<${item.idProp.type}><% } %> {
  /** A unique URI prefix for RESTful services and multi-language support */
  public static final String URI_PREFIX = "$item.uri";
  <% item.props.each { prop-> if(prop.typeRef.typeEntity && (prop.manyToOne || prop.oneToOne)) { def relationIdProp = prop.typeEl.idProp %>

  $relationIdProp.computedType get${prop.capName}${relationIdProp.capName}();

  void set${prop.capName}${relationIdProp.capName}($relationIdProp.computedType ${prop.name}${relationIdProp.capName});
  <% } } %><% item.props.each { prop-> if(!prop.relation && prop.name!='id') { %>
  <% if(prop.description) { %>
  /** $prop.description */<% } %>
  $prop.computedType $prop.getter;

  void set${prop.capName}($prop.computedType $prop.name);<% }%><% } %>
  ${macros.apply('interfaceBody')}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.service.base = '''<% def className = item.names.base %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.util.Date;
import java.util.List;
import java.util.Map;$item.imports
import ${destModule.namespaces.model}.*;

<% if(!item.base) { %>
/**
* The service provides public operations for '$module.name'.<% if(item.description) { %>
* <p>
* $item.description
* </p><% } %>
*/<% } else { %>/** Base interface of {@link $item.name} */<% } %>
public interface $className {
  ${macros.apply('interfaceBodyExternal')}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>'''

common.backend.service.bean = '''<% if(item.base) { %><% def className = item.names.bean %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;
import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.ejb.Remote;
import javax.ejb.Stateless;
import java.util.Date;
import java.util.List;
import java.util.Map;
$item.imports
import com.siemens.ra.cg.pl.common.base.annotations.Service;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${destModule.namespaces.model}.*;
import ${destModule.namespace}.${item.namespace}.$item.name;

/** Ejb implementation of {@link $item.name} */
@Service
@Stateless(name = SERVICE_${item.underscoredName}, mappedName = SERVICE_${item.underscoredName})
@Remote(${item.name}.class)
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $item.names.baseBean {
  ${macros.apply('implOperations')}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

common.backend.service.baseBean = '''<% def className = item.names.baseBean %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;<% def refs=item.refs.logicUnits %>
<% if(!item.base) { %>
import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;
<% } %>
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.inject.Inject;<% if(!item.base) { %>
import javax.ejb.Remote;
import javax.ejb.Stateless;

import com.siemens.ra.cg.pl.common.base.annotations.Service;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;<% } %>
${macros.apply('importRefs')}
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;
import ${destModule.namespace}.${item.namespace}.${item.name};
import com.siemens.ra.cg.pl.common.base.cdi.Internal;<% if(item.useConverter) { %>
import ${destModule.namespaces.integ}.${module.names.converter};<% } %>

/** Ejb implementation of {@link $item.name} */<% if(!item.base) { %>
@Service
@Stateless(name = SERVICE_${item.underscoredName}, mappedName = SERVICE_${item.underscoredName})
@Remote(${item.name}.class)
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })<% } %>
public ${item.base?'abstract ':''}class $className implements $item.name {<% if(item.useConverter) { %>
  protected $module.names.converter converter;<% } %>
  ${macros.apply('refsMembers')}
  <% item.operations.each { op-> if(op.body) { %>

  @Override<% if(op.rawType) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $op.returnTypeExternal ${op.nameExternal}($op.signature) {
    $op.body
  }<% } %><% } %><% item.refs.delegates.each { opRef-> def ref = opRef.reference(); def op = ref?.op; if(op) { def raw = opRef.rawType || (opRef.resultExpression && ref.el.multi && ref.el.typeRef.typeEntity) %>

  @Override<% if(raw) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public $opRef.returnTypeExternal ${opRef.nameExternal}($opRef.signatureExternal) {<% if(op.void) { %>
    ${op.parent.names.instance}.${op.name}($opRef.signatureNamesExternal);<% }else { %><% if(opRef.resultExpression) { %>
    $op.returnTypeExternal ret = ${op.parent.names.instance}.${op.name}($opRef.signatureNamesExternal);
    if(ret != null) {
      $op.returnType entity = ($op.returnType)ret;<% if(raw) { %>
      //load LAZY loading
      entity.${ref.el.getter}.size();
      return (List)entity.${ref.el.getter};<% } else { if(item.useConverter && ref.returnTypeEjb) { %>
      return converter.toExternal(entity.${ref.el.getter});<% } else { %>
      return entity.${ref.el.getter};<% } } %>
    } else {
      return null;
    }<% } else { %>
    $opRef.returnTypeRaw ret = ${op.parent.names.instance}.${op.name}($op.signatureNamesExternal);<% if(item.useConverter && ref.returnTypeEjb) { %>
    ret = converter.toExternal(ret);<% } %>
    return ret;<% } %><% } %>
  }<% } %><% } %>
  ${macros.apply('implInjects')}<% if(item.useConverter) { %>

  @Inject
  public void set${module.names.converter}($module.names.converter converter) {
    this.converter = converter;
  }<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.service.delegateTest = '''<% def className = "${item.names.clazz}DelegateTest" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;

public class $className extends ${className}Base { 
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.service.delegateTestBase = '''<% def className = "${item.names.clazz}DelegateTestBase" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.ejb;<% def refs=item.refs.logicUnits %>

import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

$item.imports
<% refs.each { ref-> %>
import ${ref.module().namespace}.${ref.namespace}.${ref.names.clazz};
<% } %>import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.ejb.*;
import ${destModule.namespace}.${item.namespace}.${item.name};<% if(module.entities) { %>
import ${destModule.namespace}.integ.$module.names.converter;<% } %>

public class $className { 

  protected static $item.names.bean $item.names.instance;
  
  @BeforeClass
  public static void beforeClass$className() {
    $item.names.instance = new $item.names.bean();<% if(item.useConverter) { %>
    ${item.names.instance}.set$module.names.converter(mock(${module.names.converter}.class));<% } %><% refs.each { ref-> %>
    ${item.names.instance}.set${ref.names.clazz}(mock(${ref.names.clazz}.class));<% } %><% item.refs.containers.each { ref -> %>
    ${item.names.instance}.set${ref.names.clazz}(mock(${ref.names.clazz}.class));<% } %>    
  }
  
  @After
  public void after$className() {
    verifyNoMoreInteractions();
  }

  @Before
  public void before$className() {
    resetMocks();
  }

  protected void verifyNoMoreInteractions() {
    Mockito.verifyNoMoreInteractions(<% first = true; refs.each { ref-> if(first) { first = false } else { %>,<% } %>
      ${item.names.instance}.${ref.names.instance}<% } %><% item.refs.containers.each { ref -> if(first) { first = false } else { %>,<% } %>
      ${item.names.instance}.${ref.names.instance}<% } %>);
  }

  protected void resetMocks() {
    Mockito.reset(<% first = true; refs.each { ref-> if(first) { first = false } else { %>,<% } %>
      ${item.names.instance}.${ref.names.instance}<% } %><% item.refs.containers.each { ref -> if(first) { first = false } else { %>,<% } %>
      ${item.names.instance}.${ref.names.instance}<% } %>);
  }<% item.refs.delegates.each { opRef-> def ref = opRef.reference(); def op = ref?.op; if(op) { def raw = op.rawType || (opRef.resultExpression && ref.el.multi && ref.el.typeRef.typeEntity) %>

  @Test
  public void ${opRef.nameTest}() {<% if(op.void) { %>
    ${item.names.instance}.${opRef.nameExternal}($opRef.signatureTestValuesExternal);<% } else if(op.typeBoolean) { %>
    when(${item.names.instance}.${op.parent.names.instance}.${op.name}($opRef.signatureTestValuesExternal)).thenReturn(true);
    assertTrue(${item.names.instance}.${opRef.nameExternal}($opRef.signatureTestValuesExternal));<% } else { %>
    when(${item.names.instance}.${op.parent.names.instance}.${op.name}($opRef.signatureTestValuesExternal)).thenReturn(null);
    assertEquals(null, ${item.names.instance}.${opRef.nameExternal}($opRef.signatureTestValuesExternal));<% } %>
    verify(${item.names.instance}.${op.parent.names.instance}).${op.name}($opRef.signatureTestValuesExternal);
  }<% } } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/ejb/${className}.java" %>'''

common.backend.service.empty = '''<% def className = "${item.name}Empty" %>
$macros.header
package ${destModule.namespace}.${item.namespace}.impl;

import java.util.Date;
import java.util.List;
import java.util.Map;
import javax.enterprise.inject.Alternative;$item.imports
import ${destModule.namespaces.model}.*;
import ${destModule.namespace}.${item.namespace}.${item.name};

/** Empty implementation of {@link $item.name} what shall be extended by Test/Mock implementation in order to avoid unnecessary work by extension of the interface. */
@Alternative
public abstract class $className implements $item.name {<% item.operations.each { op -> %>

  @Override
  public $op.returnTypeExternal ${op.nameExternal}($op.signature) {<% if(op.typeBoolean) { %>
    return false;<% } else if(!op.void) { %>
    return null;<% } %>
  }<% } %><% item.refs.delegates.each { opRef-> def op = opRef.reference()?.op; if(op) { %>

  @Override
  public $opRef.returnTypeExternal ${opRef.nameExternal}($opRef.signatureExternal) {<% if(op.typeBoolean) { %>
    return false;<% } else if(!op.void) { %>
    return null;<% } %>
  }<% } %><% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/impl/${className}.java" %>'''

common.backend.service.ifc = '''<% if(item.base) { %><% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/**
* The service provides public operations for '$module.name'.<% if(item.description) { %>
* <p>
* $item.description
* </p><% } %>
*/
public interface $className extends $item.names.base {
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>'''

common.backend.service.provider = '''<% def className = item.names.provider %>
$macros.header
package ${destModule.namespace}.${item.namespace}.provider;

import static ${shared.namespaces.integ}.${module.shared.names.constants}.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
$item.imports
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.ejb.locator.ServiceLocator;
import com.siemens.ra.cg.pl.common.ejb.locator.ServiceProviderRemote;
import ${destModule.namespace}.${item.namespace}.$item.name;

/** Service provider for remote implementation of {@link $item.name} */
@ApplicationScoped
@Traceable
public class $className extends ServiceProviderRemote<$item.name> {
  public static final String BEAN = SERVICE_${item.underscoredName};

  public $className() {
    super(BEAN, ${item.name}.class);
  }

  public $className(ServiceLocator serviceLocator, boolean cacheService, boolean lazyInit) {
    super(BEAN, ${item.name}.class, serviceLocator, cacheService, lazyInit);
  }

  public void onChangeServiceLocator(@Observes(notifyObserver = Reception.IF_EXISTS) ServiceLocator serviceLocator) {
    setServiceLocator(serviceLocator);
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/provider/${className}.java" %>'''


common.component.module.realm = '''<% def realm = component.realm; if (realm) {%>
// users <%
realm.users.each { user-> %> 
createUser('$user.name', '${user.pass}', '${user.getUserDescription()}')<% } %>

// groups <%
realm.groups.each { group-> %>
createGroup('$group.name', '${group.groupDescription}')<% } %>

// roles <%
realm.roles.each { role-> %>
createRole('${component.uncapShortName}_$role.name', '${role.roleDescription}')<% } %>

// user-group mappings <%
realm.users.each { user-> user.groupRefs.each { group-> %>
addUserToGroup('$user.name', '$group')<% } } %>

// group-roles mapping <%
realm.roles.each { role-> %>
setRoleGroups('${component.uncapShortName}_$role.name', [${role.getQuotedGroupNames()}])<% } %>

// state machine additions <%
def stateMachines = component.stateMachines.findAll{it.generatePermissionsForEvents}
def eventNames = stateMachines.events.name.flatten() as Set
eventNames.each{ eventName-> %>
createRole('${component.uncapShortName}_$eventName', 'Role for $eventName')<%
}
stateMachines.each{
it.getEventGroupsMap().each{key, value -> if (value) {%>
setRoleGroups('${component.uncapShortName}_$key', [$value])<%}}}
if (stateMachines) {%>
setRoleUsers('${component.uncapShortName}_timeout', ['weblogic'])
<%}%>
<% ret.path = "${destModule.srcGenMain}/cfg/weblogic/${component.uncapShortName}-realm.groovy"}%>'''


common.stateMachine.module.actionExecutor = '''<% def className = module.names.actionExecutor %>
$macros.header
package ${destModule.namespaces.core};

import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${destModule.namespaces.model}.$module.names.actionType;
import ${destModule.namespaces.model}.$module.names.event;

/**
* An action handler is responsible to execute a transition or state action of for state machine $module.name.
* The execution result is a boolean value, what is handled as transition condition.
* If it is false, then the transition can not be applied and the state event handler will proceed with next possible transitions or abort the event processing.
*/
public interface $className {

  $module.names.actionType getType();

  boolean execute($module.names.event event, $module.entity.names.clazz $module.entity.uncapName, $module.stateProp.type oldState, $module.stateProp.type newState, $module.context.names.clazz context);
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.actionType = '''<% def className = module.names.actionType %>
$macros.header
package ${destModule.namespaces.model};

import com.siemens.ra.cg.pl.common.base.ml.MLKey;
import com.siemens.ra.cg.pl.common.base.ml.MLKeyImpl;
import ${shared.namespaces.integ}.${shared.names.ml};

/** Actions Enum of state machine $module.name */
public enum $className { <% def literals = module.actions.collect {
  if (it.description){ "   /** $it.description */   $it.names.literalInit" }else { it.names.literalInit } }.join(',   ') %>
  $literals;<% module.actions.each { action-> %>

  public boolean is${action.capName}() {
    return this == $action.underscoredName;
  }<% } %>

  public MLKey buildMlKey() {
    return new MLKeyImpl(${shared.names.ml}.ML_BASE, name());
  }  
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.controller = '''<% def controller = module.controller; if (controller.base) { def className = controller.names.clazz; %>
$macros.header
package ${destModule.namespaces.core};

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
${macros.apply(name: 'importRefs', item: controller)}

<% if (module.description) { %>/**
* $module.description
*/<% } else { %>/** The controller is the entry point for state machine $module.name */<% } %>
public interface $className extends $controller.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>
'''

common.stateMachine.module.controllerBase = '''<% def controller = module.controller; def className = controller.names.base; %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import java.util.Date;
import java.util.List;
import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
${macros.apply(name: 'importRefs', item: controller)}
import ${module.entity.nameFull()};
import ${destModule.namespaces.model}.${module.names.event};
import ${destModule.namespaces.model}.meta.${module.names.metaModel};

<% if (module.description) { %>/**
* $module.description
*/<% } else { %>/** Event processor for state machine $module.name */<% } %>
public interface $className {
  $module.entity.names.clazz process($module.names.event event);
  $module.names.metaModel findStateMetaModel();
  ${macros.apply(name: 'interfaceBody', item: controller)}
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.controllerBaseImpl = '''<% def controller = module.controller; def className = controller.names.baseImpl; def idProp = module.entity.idProp; def managerInjected = (controller.refs.logicUnits.find { it == module.entity.manager}) %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;<% if(!controller.base) { %>

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;<% } %>

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import java.util.Date;
import java.util.List;
import javax.inject.Inject;<% if(controller.base) { %>
import javax.enterprise.inject.Alternative;<% } else { %>
import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;<% } %>
import com.siemens.ra.cg.pl.common.base.integ.CommonConstants;
import com.siemens.ra.cg.pl.common.base.exception.IllegalStateException;
import com.siemens.ra.cg.pl.common.base.model.SessionPrincipal;
import ${shared.namespaces.integ}.$module.shared.names.constants;
import ${module.entity.manager.nameFull()};
import ${module.stateProp.typeEl.nameFull()};
import ${module.context.nameFull()};
import ${module.entity.nameFull()};
import ${shared.namespaces.integ}.${shared.names.ml};
import ${destModule.namespaces.core}.*;
import ${destModule.namespaces.model}.*;
import ${destModule.namespaces.model}.meta.${module.names.metaModel};
${macros.apply(name: 'importRefs', item: controller)}

<% if (controller.base) { %>@Alternative<% }else { %>@Controller
@ApplicationScoped
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })<% } %>
@SuppressWarnings("unused")
public class $className implements $controller.names.clazz {
  protected final XLogger log = XLoggerFactory.getXLogger(getClass());
  <% module.states.each { def state-> %>
  protected $state.names.eventProcessor ${state.uncapName}EventProcessor;<% } %><% if(!managerInjected) { %>
  protected $module.entity.manager.names.clazz $module.entity.manager.names.instance;<% } %>
  protected $module.names.metaModel stateMetaModel;
  protected SessionPrincipal sessionPrincipal;
  ${macros.apply(name: 'refsMembers', item: controller)}

  @Override
  public $module.entity.names.clazz process($module.names.event event) {
    log.debug("process({})", event);
    $module.context.names.clazz context = new $module.context.names.clazz();
    $module.entity.names.clazz ret = ${module.entity.manager.names.instance}.findByIdNotNull(event.get${idProp.capFullname}());
    validateExpectedAndCurrentState(event, ret, context);
    $module.names.stateEventProcessor stateEventProcessor = findEventProcessorNotNull(ret, context);
    ret = stateEventProcessor.process(event, ret, context);
    return ret;
  }

  @Override
  public $module.names.metaModel findStateMetaModel() {
    return stateMetaModel;
  }

  protected $module.names.stateEventProcessor findEventProcessorNotNull($module.entity.names.clazz $module.entity.uncapName, $module.context.names.clazz context) {
    $module.names.stateEventProcessor ret;
    ${module.stateProp.type} $module.stateProp.name = ${module.entity.uncapName}.get$module.stateProp.capName();

    <% module.states.each { def state-> %>if (${module.stateProp.name}.is${state.capName}()) {
      ret = ${state.uncapName}EventProcessor;
    } else <% } %>{
      throw new IllegalStateException(CommonConstants.ML_BASE, CommonConstants.ML_KEY_UNEXPECTED_EVENT_FOR_STATE, ${module.entity.uncapName}.get$idProp.capName(), $module.stateProp.name, ${module.entity.uncapName});
    }
    return ret;
  }

  protected void validateExpectedAndCurrentState($module.names.event event, $module.entity.names.clazz $module.entity.names.instance, $module.context.names.clazz context) {
    //check if expected state and current state are same
    if (event.getExpectedState() != null) {
      if (!event.getExpectedState().equals(${module.entity.names.instance}.get$module.stateProp.capName())) {
        throw new IllegalStateException(CommonConstants.ML_BASE, CommonConstants.ML_KEY_EXPECTED_AND_CURRENT_STATE_DIFFERENT,
            event.getExpectedState(), ${module.entity.names.instance}.get$module.stateProp.capName(), ${module.entity.names.instance}.get$idProp.capName(), ${module.entity.names.instance});
      }
    }
  }
  ${macros.apply(name: 'implOperationsAndDelegates', override: true, item: controller)}
  ${macros.apply(name: 'implInjects', item: controller)}

  @Inject
  public void set$module.names.metaModel($module.names.metaModel stateMetaModel) {
    this.stateMetaModel = stateMetaModel;
  }

  @Inject
  public void setSessionPrincipal(SessionPrincipal sessionPrincipal) {
    this.sessionPrincipal = sessionPrincipal;
  }<% if(!managerInjected) { %>

  @Inject
  public void set$module.entity.manager.name($module.entity.manager.names.clazz $module.entity.manager.names.instance) {
    this.$module.entity.manager.names.instance = $module.entity.manager.names.instance;
  }<% } %><% module.states.each { def state-> %>

  @Inject
  public void set$state.names.eventProcessor($state.names.eventProcessor ${state.uncapName}EventProcessor) {
    this.${state.uncapName}EventProcessor = ${state.uncapName}EventProcessor;
  }<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java" %>'''

common.stateMachine.module.controllerBaseTest = '''<% def controller = module.controller; def className = "${controller.names.base}TestImpl"; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import static org.junit.Assert.*;
import java.util.HashMap;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import ${module.entity.nameFull()};
import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.module().namespaces.model}.${module.entity.module().names.dataFactory}Base;
import ${module.entity.manager.nameFull()};
import ${destModule.namespaces.model}.$module.names.eventFactory;
import ${destModule.namespaces.model}.$module.names.event;
import ${destModule.namespaces.model}.$module.names.eventType;
import ${destModule.namespaces.model}.meta.$module.names.metaState;
import ${destModule.namespaces.model}.meta.$module.names.metaModel;
import com.siemens.ra.cg.pl.common.base.cdi.Internal;
import com.siemens.ra.cg.pl.common.state.model.StateFlowType;<% if (module.history) { %>
import com.siemens.ra.cg.pl.um.test.UmTestUtils;
import ${module.entity.nameFull()};<% } %>

@ApplicationScoped
public abstract class $className {
  protected final XLogger log = XLoggerFactory.getXLogger(getClass());
  protected final static int MAX_STATE_OCCURENCES = 3;
  
  protected $module.entity.manager.names.clazz $module.entity.manager.names.instance;
  protected $controller.names.clazz $controller.names.instance;
  protected ${module.entity.module().names.dataFactory}Base dataFactory;

  protected $module.entity.names.clazz $module.entity.names.instance;
  protected $module.names.metaModel stateMetaModel;
  protected $module.names.eventFactory eventFactory;<% if (module.history) { %>
  protected UmTestUtils umTestUtils;<% } %>

  protected HashMap<$module.stateProp.type, Integer> stateOccurences = new HashMap<>();

  @Before
  public void before() {
    $module.entity.names.instance = ${module.entity.manager.names.instance}.create(dataFactory.new${module.entity.capName}(1));
    assertNotNull("$module.entity.names.clazz object is null.", $module.entity.names.instance);
    stateMetaModel = ${controller.names.instance}.findStateMetaModel();
    assertNotNull("State meta model is null.", stateMetaModel);<% if (module.history) { %>
    assertNotNull(umTestUtils.loginUserWithAllGroups(UmTestUtils.ADMINISTRATOR_NAME));<% } %>

    for ($module.stateProp.type state : ${module.stateProp.type}.values()) {
      stateOccurences.put(state, 0);
    }
  }

  @After
  public void after() {<% if (module.history) { %>
    umTestUtils.logout();<% } %>
    try {
      ${module.entity.manager.names.instance}.delete(${module.entity.names.instance}.$idProp.getter);
    } catch (Exception e) {
      log.error("Exception in after {}", e);
    }
  }

  @Test
  @Ignore
  public void testProcessNormalFlow() {
    testProcess(StateFlowType.NORMAL);
  }

  public void testProcess(StateFlowType flowType) {
    boolean run = true;<% if (module.history) { %>
    long count = 0;<% } %>
    while (run) {
      $module.stateProp.type startState = ${module.entity.names.instance}.$module.stateProp.getter;
      log.info("Processing with state {} and $module.entity.uncapName {}", startState, ${module.entity.names.instance});
      $module.names.metaState metaState = stateMetaModel.findMetaState(startState);
      if (metaState != null && metaState.getEvents().size() > 0) {

        for ($module.names.eventType eventType : metaState.getEvents()) {
          if (flowType.equals(eventType.getFlowType())) {
            $module.names.event event = eventFactory.new$module.names.event(eventType, ${module.entity.names.instance}.getId(), metaState.getState());
            fillEvent(event);
            log.info("Send event {}", event);

            $module.entity.names.instance = ${controller.names.instance}.process(event);<% if (module.history) { %>
            count++;
            assertEquals((($module.entity.names.bean) $module.entity.names.instance).get${module.histProp.capName}().size(), count);<% } %>

            log.info("Result state {} and $module.entity.uncapName {}", ${module.entity.names.instance}.getState(), $module.entity.names.instance);
            if (!startState.equals(${module.entity.names.instance}.getState())) {
              break;
            }
          }
        }

        $module.stateProp.type currentState = ${module.entity.names.instance}.getState();
        int stateOccurence = stateOccurences.get(currentState) + 1;
        stateOccurences.put(currentState, stateOccurence);

        //check if transitions for given flow type changed the state, if not exit.
        if (startState.equals(currentState)) {
          fail(String.format("Exit after state %s, because the state did not change after transition. Workflow might not be fully tested.", currentState));
        }

        //to avoid a infinite loop in workflow a certain state can only be passed a 'MAX_STATE_OCCURENCES' times
        if (stateOccurence > MAX_STATE_OCCURENCES) {
          String msg = String.format("Exit after %s times for same state %s. Following states are tested %s. Workflow might not be fully tested.",
              stateOccurence, currentState, stateOccurences);
          log.info(msg);
          fail(msg);
        }

      } else {
        run = false;
      }
    }
    log.info("End processing with state {} and $module.entity.uncapName {}", ${module.entity.names.instance}.getState(), $module.entity.names.instance);
  }

  /** Fill event event in sub class with additional event parameters */
  protected void fillEvent($module.names.event event) {
    log.debug("fillEvent({})", event);
  }

  @Inject
  public void set$controller.names.clazz($controller.names.clazz $controller.names.instance) {
    this.$controller.names.instance = $controller.names.instance;
  }

  @Inject
  public void set$module.entity.manager.name($module.entity.manager.names.clazz $module.entity.manager.names.instance) {
    this.$module.entity.manager.names.instance = $module.entity.manager.names.instance;
  }

  @Inject
  public void setDataFactory(@Internal ${module.entity.module().names.dataFactory}Base dataFactory) {
    this.dataFactory = dataFactory;
  }

  @Inject
  public void setEventFactory($module.names.eventFactory eventFactory) {
    this.eventFactory = eventFactory;
  }<% if (module.history) { %>

  @Inject
  public void setUmTestUtils(UmTestUtils umTestUtils) {
    this.umTestUtils = umTestUtils;
  }<% } %>
}<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.controllerImpl = '''<% def controller = module.controller; def className = controller.names.impl; if (controller.base) { %>
$macros.header
package ${destModule.namespace}.${controller.namespace}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;

@Controller
@ApplicationScoped
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $controller.names.baseImpl {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/impl/${className}.java"; } %>
'''

common.stateMachine.module.controllerLocalTestInteg = '''<% def controller = module.controller; def className = "${controller.names.clazz}LocalTestInteg" %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;

import org.junit.runner.RunWith;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.cdi.weld.LocalWeldRunner;

@RunWith(LocalWeldRunner.class)
@SupportsEnvironments(@Environment(executions = { LOCAL }))
public class $className extends ${controller.names.clazz}TestImpl {
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.controllerMemoryTestInteg = '''<% def controller = module.controller; def className = "${controller.names.clazz}MemoryTestInteg" %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;

import org.junit.runner.RunWith;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.cdi.weld.MemoryWeldRunner;

@RunWith(MemoryWeldRunner.class)
@SupportsEnvironments(@Environment(executions = { MEMORY }))
public class $className extends ${controller.names.clazz}TestImpl {
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.controllerTest = '''<% def controller = module.controller; def className = "${controller.names.clazz}TestImpl" %>
$macros.header
package ${destModule.namespace}.${controller.namespace};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;

import org.junit.runner.RunWith;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.cdi.weld.LocalWeldRunner;

public abstract class $className extends ${controller.names.clazz}BaseTestImpl {
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${controller.namespace.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.event = '''<% def className = "$module.names.event"; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespaces.model};

import ${module.stateProp.typeEl.nameFull()};

/** Base state event interface for all state events of state machine $module.name */
public interface $className {

  /**
  * Expected state defines a kind of a limitation of the event. If the value is null, than the limitation will be ignored.
  * If it is not null, then the event is valid only if the current state of $module.entity.names.clazz is same.
  * If the expected value is not equal to the current state, then the event will be rejected.
  */
  $module.stateProp.type getExpectedState();

  $idProp.type get$idProp.capFullname();

  void set$idProp.capFullname($idProp.type $idProp.uncapFullname);

  void setExpectedState($module.stateProp.type expectedState);

  $module.names.eventType getType();

  void setActor(String actor);

  String getActor();
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.eventFactory = '''<% def className = "$module.names.eventFactory"; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespaces.model};

import ${module.stateProp.typeEl.nameFull()};

/** Factory for all state events of state machine $module.name */
public interface $className {
  $module.names.event new$module.names.event($module.names.eventType type, $idProp.type $idProp.uncapFullname);

  $module.names.event new$module.names.event($module.names.eventType type, $idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState);<% module.events.each { event-> %><% if(!event.props) { %>

  ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname);<% } %>

  ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState);<% if(event.props) { %>

  ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $event.signatureFullConstr);

  ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState, $event.signatureFullConstr);<% } %><% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.eventFactoryImpl = '''<% def className = "$module.names.eventFactoryImpl"; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespaces.model}.impl;

import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.exception.IllegalStateException;
import ${shared.namespaces.integ}.${shared.names.ml};
import ${module.stateProp.typeEl.nameFull()};
import ${destModule.namespaces.model}.*;

@ApplicationScoped
@Traceable
public class $className implements $module.names.eventFactory {

  @Override
  public $module.names.event new$module.names.event($module.names.eventType type, $idProp.type $idProp.uncapFullname) {
    return new$module.names.event(type, $idProp.uncapFullname, null);
  }

  @Override
  public $module.names.event new$module.names.event($module.names.eventType type, $idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState) {
    $module.names.event ret;

    <% module.events.each { def event-> %>if (type.is${event.capName}()) {
      ret = new${event.names.clazz}($idProp.uncapFullname, expectedState);
    } else <% } %>{
      throw new IllegalStateException(${shared.names.ml}.ML_BASE, "no_state_event", type);
    }
    return ret;
  }<% module.events.each { event-> %><% if(!event.props) { %>

  @Override
  public ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname) {
    return new $event.names.impl($idProp.uncapFullname);
  }<% } %>

  @Override
  public ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState) {
    return new $event.names.impl($idProp.uncapFullname, expectedState);
  }<% if(event.props) { %>

  @Override
  public ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $event.signatureFullConstr) {
    return new $event.names.impl($idProp.uncapFullname, $event.signatureNamesFullConstr);
  }

  @Override
  public ${event.names.clazz} new${event.names.clazz}($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState, $event.signatureFullConstr) {
    return new $event.names.impl($idProp.uncapFullname, expectedState, $event.signatureNamesFullConstr);
  }<% } %><% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.module.eventImpl = '''<% def className = "${module.names.event}Impl"; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespaces.model}.impl;

import com.siemens.ra.cg.pl.common.base.model.Base;
import ${module.stateProp.typeEl.nameFull()};
import ${destModule.namespaces.model}.${module.names.eventType};
import ${destModule.namespaces.model}.${module.names.event};

/** Base implementation of {@link $module.names.event} */
public abstract class $className extends Base implements ${module.names.event} {
  private static final long serialVersionUID = 1L;

  protected final $module.names.eventType type;
  protected $module.stateProp.type expectedState;
  protected $idProp.type $idProp.uncapFullname;
  protected String actor;

  protected $className($module.names.eventType type) {
    this.type = type;
  }

  protected $className($module.names.eventType type, $idProp.type $idProp.uncapFullname) {
    this.type = type;
    this.$idProp.uncapFullname = $idProp.uncapFullname;
  }

  protected $className($module.names.eventType type, $idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState) {
    this.type = type;
    this.$idProp.uncapFullname = $idProp.uncapFullname;
    this.expectedState = expectedState;
  }

  @Override
  public $module.stateProp.type getExpectedState() {
    return expectedState;
  }

  @Override
  public String getActor() {
    return actor;
  }

  @Override
  public $idProp.type get$idProp.capFullname() {
    return $idProp.uncapFullname;
  }

  @Override
  public void set$idProp.capFullname($idProp.type $idProp.uncapFullname) {
    this.$idProp.uncapFullname = $idProp.uncapFullname;
  }

  @Override
  public void setExpectedState($module.stateProp.type expectedState) {
    this.expectedState = expectedState;
  }

  @Override
  public void setActor(String actor) {
    this.actor = actor;
  }

  @Override
  public $module.names.eventType getType() {
    return type;
  }

  @Override
  protected void fillToString(StringBuffer buffer) {
    super.fillToString(buffer);
    buffer.append("type=").append(type).append(SEPARATOR);
    buffer.append("expectedState=").append(expectedState).append(SEPARATOR);
    buffer.append("actor=").append(actor).append(SEPARATOR);
    buffer.append("${idProp.uncapFullname}=").append($idProp.uncapFullname);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((expectedState == null) ? 0 : expectedState.hashCode());
    result = prime * result + ((actor == null) ? 0 : actor.hashCode());
    result = prime * result + ((${idProp.uncapFullname} == null) ? 0 : ${idProp.uncapFullname}.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    $className other = ($className) obj;
    if (expectedState != other.expectedState)
      return false;
    if (actor == null) {
      if (other.actor != null)
        return false;
    } else if (!actor.equals(other.actor))
      return false;
    if (${idProp.uncapFullname} == null) {
      if (other.${idProp.uncapFullname} != null)
        return false;
    } else if (!${idProp.uncapFullname}.equals(other.${idProp.uncapFullname}))
      return false;
    if (type != other.type)
      return false;
    return true;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.module.eventType = '''<% def className = module.names.eventType %>
$macros.header
package ${destModule.namespaces.model};

import static com.siemens.ra.cg.pl.common.state.model.StateFlowType.*;

import com.siemens.ra.cg.pl.common.base.ml.MLKey;
import com.siemens.ra.cg.pl.common.base.ml.MLKeyImpl;
import com.siemens.ra.cg.pl.common.state.model.StateFlowType;
import ${shared.namespaces.integ}.${shared.names.ml};

/** Events of state machine '$module.name' */
public enum $className { <% def literals = module.events.collect {
  if (it.description){ "   /** $it.description */   $it.names.literalInit" }else { it.names.literalInit } }.join(',   ') %>
  $literals;

  private StateFlowType flowType;

  private $className(StateFlowType flowType) {
    this.flowType = flowType;
  }<% module.events.each { event-> %>

  public boolean is${event.capName}() {
    return this == $event.underscoredName;
  }<% } %>

  public MLKey buildMlKey() {
    return new MLKeyImpl(${shared.names.ml}.ML_BASE, name());
  }

  public StateFlowType getFlowType() {
    return flowType;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.metaModel = '''<% def className = module.names.metaModel %>
$macros.header
package ${destModule.namespaces.model}.meta;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.Arrays;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

import com.siemens.ra.cg.pl.common.base.model.Base;
import ${module.stateProp.typeEl.nameFull()};

/** Meta model for state machine $module.name provides static information of available states, events and actions. */
@ApplicationScoped
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY, PRODUCTIVE }, runtimes = { CLIENT }) })
public class $className extends Base {
  private static final long serialVersionUID = 1L;
  <% module.states.each { state -> %>
  private $state.names.metaState ${state.uncapName}MetaState;<% } %>
  
  private $module.names.metaState[] metaStates;

  public $className() {
    super();
  }

  protected $className($module.names.metaState[] metaStates) {
    super();
    this.metaStates = metaStates;
  }

  @PostConstruct
  public void postConstruct() {
    metaStates = new $module.names.metaState[] {   <% def metaStates = module.states.collect { state -> "${state.uncapName}MetaState" }.join(',\\n      ') %>
      $metaStates
    };
  }

  public $className copy(){
    return new $className(metaStates);
  }

  public $module.names.metaState[] getMetaStates() {
    return metaStates;
  }

  public $module.names.metaState findMetaState($module.stateProp.type state) {
    $module.names.metaState ret = null;
    if (state != null) {
      for ($module.names.metaState metaState : metaStates) {
        if (state.equals(metaState.getState())) {
          ret = metaState;
          break;
        }
      }
    }
    return ret;
  }

  @Override
  protected void fillToString(StringBuffer buffer) {
    super.fillToString(buffer);
    buffer.append("metaStates=").append(Arrays.toString(metaStates));
  }

<% module.states.each { state -> %>
  @Inject
  public void set$state.names.metaState($state.names.metaState ${state.uncapName}MetaState) {
    this.${state.uncapName}MetaState = ${state.uncapName}MetaState;
  } 
<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/meta/${className}.java" %>
'''

common.stateMachine.module.metaState = '''<% def className = module.names.metaState %>
$macros.header
package ${destModule.namespaces.model}.meta;

import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.enterprise.inject.Alternative;

import com.siemens.ra.cg.pl.common.base.model.Base;
import com.siemens.ra.cg.pl.common.base.integ.RoleValidator;
import com.siemens.ra.cg.pl.common.base.model.SessionPrincipal;
import com.siemens.ra.cg.pl.common.ejb.cond.UserInRoleConditionVerifier;
import com.siemens.ra.cg.pl.common.base.util.ClassUtils;
import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${module.conditionEntity.nameFull()};
import ${destModule.namespaces.model}.$module.names.eventType;

/** Static information about events and actions for a state of state machine $module.name */
@Alternative
public abstract class $className extends Base {
  private static final long serialVersionUID = 1L;

  protected ${module.stateProp.typeEl.name} state;
  protected List<$module.names.eventType> events;<% module.notifiables.each { toBeNotified -> %> 
  protected boolean ${toBeNotified}ToBeNotified = false;<% } %>
  protected UserInRoleConditionVerifier userInRoleConditionVerifier;

  // required to be proxyable
  protected $className() {
    super();
  }

  public $className(${module.stateProp.typeEl.name} state, List<$module.names.eventType> events) {
    super();
    this.state = state;
    this.events = events;
  }

  public $module.stateProp.type getState() {
    return state;
  }

  public List<$module.names.eventType> getEvents() {
    return events;
  }<% module.notifiables.each { toBeNotified -> %> 

  public boolean is${toBeNotified.capitalize()}ToBeNotified() {
    return ${toBeNotified}ToBeNotified;
  }<% } %>

  public abstract List<$module.names.eventType> findPossibleEvents($module.entity.names.clazz $module.entity.uncapName, $module.context.names.clazz context);

  @Override
  protected void fillToString(StringBuffer buffer) {
    super.fillToString(buffer);
    buffer.append("state=").append(state).append(SEPARATOR);
    buffer.append("events=").append(events);
  }
  
  @Inject
  public void setUserInRoleConditionVerifier(UserInRoleConditionVerifier userInRoleConditionVerifier) {
    this.userInRoleConditionVerifier = userInRoleConditionVerifier;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/meta/${className}.java" %>
'''

common.stateMachine.module.stateEventProcessor = '''<% def className = module.names.stateEventProcessor %>
$macros.header
package ${destModule.namespaces.core};

import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${destModule.namespaces.model}.${module.names.event};

/** Event processor for single state of the state machine $module.name */
public interface $className {
  $module.entity.names.clazz process($module.names.event event, $module.entity.names.clazz $module.entity.uncapName, $module.context.names.clazz context);
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.module.stateEventProcessorBaseImpl = '''<% def className = "${module.names.stateEventProcessor}BaseImpl" %>
$macros.header
package ${destModule.namespaces.core}.impl;

import java.util.Date;
import java.util.List;
import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.integ.CommonConstants;
import com.siemens.ra.cg.pl.common.base.annotations.Traceable;
import com.siemens.ra.cg.pl.common.base.exception.IllegalStateException;
import com.siemens.ra.cg.pl.common.base.integ.RoleValidator;
import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import com.siemens.ra.cg.pl.common.base.util.StringUtils;
import static com.siemens.ra.cg.pl.common.base.util.TimeUtils.*;

import ${module.entity.manager.nameFull()};
import ${module.context.nameFull()};
import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.nameFull()};
import ${destModule.namespaces.model}.meta.${module.names.metaModel};
import ${destModule.namespaces.core}.$module.names.stateEventProcessor;<% if (module.timeoutEnabled) { %>
import ${destModule.namespaces.model}.${module.capShortName}Timeouts;<% } %>
import ${destModule.namespaces.model}.$module.names.eventType;
import ${destModule.namespaces.model}.${module.names.event};
import ${destModule.namespaces.model}.${module.names.transitionExecutionResult};
import com.siemens.ra.cg.pl.common.base.model.SessionPrincipal;
import com.siemens.ra.cg.pl.common.ejb.cond.UserInRoleConditionVerifier;<% if (module.history) { %>
import ${module.history.manager.nameFull()};
import ${module.history.entity.nameFull()};
import ${module.history.entity.nameFull('bean')};
import javax.enterprise.event.Observes;<% } %>

@Traceable
@SuppressWarnings("unused")
public class $className implements $module.names.stateEventProcessor {
  protected final XLogger log = XLoggerFactory.getXLogger(getClass());
  protected final String source = StringUtils.formatSource(this);

  protected $module.entity.manager.names.clazz $module.entity.manager.names.instance;
  protected SessionPrincipal sessionPrincipal;<% if (module.history) { %>
  protected $module.history.manager.names.clazz $module.history.manager.names.instance;<% } %>
  protected RoleValidator roleValidator;
  protected $module.names.metaModel stateMetaModel;<% if (module.timeoutEnabled) { %>
  protected ${module.capShortName}Timeouts stateTimeouts;<% } %>
  protected UserInRoleConditionVerifier userInRoleConditionVerifier;

  @Override
  public $module.entity.names.clazz process($module.names.event event, $module.entity.names.clazz $module.entity.uncapName, $module.context.names.clazz context) {
    log.warn("Unexpected event type for current state - process({}, {})", event, $module.entity.uncapName);
    throw new IllegalStateException(CommonConstants.ML_BASE, CommonConstants.ML_KEY_UNEXPECTED_EVENT_FOR_STATE,
        event.getType(), ${module.entity.uncapName}.$module.stateProp.getter, event, $module.entity.uncapName);
  }

  protected $module.entity.names.clazz processNoValidFlow($module.names.event event, $module.entity.names.clazz $module.entity.uncapName, List<$module.names.transitionExecutionResult<?>> transitionResults, $module.context.names.clazz context) {
    log.info("processNoValidFlow({}, {}, {})", event, $module.entity.uncapName, transitionResults);
    $module.names.transitionExecutionResult<?> lastResult = CollectionUtils.findLast(transitionResults);
    throw new IllegalStateException(CommonConstants.ML_BASE, CommonConstants.ML_KEY_NO_VALID_FLOW, lastResult.getFromStateAsMlKey(), lastResult.getToStateAsMlKey(), lastResult.getEventTypeAsMlKey(), lastResult.getFailedActionAsMlKey());
  }

  protected void traceValidFlow($module.names.event event, $module.entity.names.clazz $module.entity.uncapName, List<$module.names.transitionExecutionResult<?>> transitionResults, $module.context.names.clazz context) {
    log.info("onValidFlowFound({}, {}, {})", event, $module.entity.uncapName, transitionResults);
  }

  protected $module.entity.names.clazz update$module.stateProp.type($module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.names.eventType eventType, $module.context.names.clazz context) {
    return update$module.stateProp.type($module.entity.names.instance, oldState, newState, eventType, true, context);
  }

  protected $module.entity.names.clazz update$module.stateProp.type($module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.names.eventType eventType, boolean fireEvent, $module.context.names.clazz context) {
    log.debug("Change the state from {} to {} to state entity {} with event type {}", oldState, newState, $module.entity.names.instance, eventType);<% if (module.history) { %>
    create$module.history.entity.name($module.entity.names.instance, oldState, newState, eventType, context);<% } %>
    ${module.entity.names.instance}.set$module.stateProp.capName(newState);
    return ${module.entity.manager.names.instance}.update$module.stateProp.capName($module.entity.names.instance, newState, fireEvent);
  }<% if (module.timeoutEnabled) { %>
  
  public void change${module.stateTimeoutProp.capName}($module.entity.names.clazz $module.entity.names.instance, int timeoutInMillis, $module.context.names.clazz context) {
    if (timeoutInMillis > 0) {
      ${module.entity.names.instance}.${module.stateTimeoutProp.setterMethodName}(createDateAddMillis(now(), timeoutInMillis));
    } else {
      clear${module.stateTimeoutProp.capName}($module.entity.names.instance, context);
    }
  }

  public void clear${module.stateTimeoutProp.capName}($module.entity.names.clazz $module.entity.names.instance, $module.context.names.clazz context) {
    ${module.entity.names.instance}.${module.stateTimeoutProp.setterMethodName}(null);
  }<% } %><% if (module.history) { def history = module.history %>

  protected void create$history.entity.name($module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.names.eventType eventType, $module.context.names.clazz context) {
    log.debug("Creating history entry for state change");
    $history.entity.names.bean ret = new $history.entity.names.bean();
    <% if (history.oldState) { %>ret.set$history.oldState.capName(oldState);
    <% }; if (history.newState) { %>ret.set$history.newState.capName(newState);
    <% }; if (history.actor) { %>ret.set$history.actor.capName(sessionPrincipal.getUser());
    <% }; if (history.action) { %>ret.set$history.action.capName(eventType.buildMlKey());
    <% }; if (history.dateOfOccurrence) { %>ret.set$history.dateOfOccurrence.capName(now());
    <% }; if (history.reason) { %>ret.set$history.reason.capName(${module.entity.names.instance}.get$history.reason.capName());
    <% }; if (history.stateMachineEntityHistoryEntries) { %>(($module.entity.names.bean)${module.entity.names.instance}).addTo$history.stateMachineEntityHistoryEntries.capName(ret);
    <% } %>
    ${module.history.manager.names.instance}.create(ret, true);
  }

  @Inject
  public void set$module.history.manager.names.clazz($module.history.manager.names.clazz $module.history.manager.names.instance) {
    this.$module.history.manager.names.instance = $module.history.manager.names.instance;
  }<% } %>

  @Inject
  public void setSessionPrincipal(SessionPrincipal sessionPrincipal) {
    this.sessionPrincipal = sessionPrincipal;
  }<% if (module.timeoutEnabled) { %>
  
  @Inject
  public void setStateTimeouts(${module.capShortName}Timeouts stateTimeouts) {
    this.stateTimeouts = stateTimeouts;
  }<% } %>

  @Inject
  public void set$module.entity.manager.name($module.entity.manager.names.clazz $module.entity.manager.names.instance) {
    this.$module.entity.manager.names.instance = $module.entity.manager.names.instance;
  }

  @Inject
  public void setRoleValidator(RoleValidator roleValidator) {
    this.roleValidator = roleValidator;
  }

  @Inject
  public void set$module.names.metaModel($module.names.metaModel stateMetaModel) {
    this.stateMetaModel = stateMetaModel;
  }

  @Inject
  public void setUserInRoleConditionVerifier(UserInRoleConditionVerifier userInRoleConditionVerifier) {
    this.userInRoleConditionVerifier = userInRoleConditionVerifier;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.module.stateEventProcessorImpl = '''<% def className = module.names.stateEventProcessorImpl %>
$macros.header
package ${destModule.namespaces.core}.impl;

import com.siemens.ra.cg.pl.common.base.annotations.Traceable;

@Traceable
public class $className extends ${module.names.stateEventProcessor}BaseImpl {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.module.stateTimeoutHandler = '''<% def className = module.names.stateTimeoutHandler; if(module.timeoutEnabled) { %>
$macros.header
package ${destModule.namespaces.core};

public interface $className {

  void registerTimer();

  void processExpired$module.entity.names.instancesCap();
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>
'''

common.stateMachine.module.stateTimeoutHandlerBean = '''<% def className = module.names.stateTimeoutHandlerBean; if(module.timeoutEnabled) { %>
$macros.header
package ${destModule.namespaces.core}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.annotation.Resource;<%if(module.generatePermissionsForEvents){%>
import javax.annotation.security.RunAs;<%}%>
import javax.ejb.Stateless;
import javax.ejb.Timeout;
import javax.ejb.TimerConfig;
import javax.ejb.TimerService;

import ${destModule.namespaces.core}.impl.$module.names.stateTimeoutHandlerImpl;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;<%if(module.generatePermissionsForEvents){%>
import ${shared.namespaces.integ}.${component.names.realm};<%}%>

@Stateless
@SupportsEnvironments(@Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }))
@Controller<%if(module.generatePermissionsForEvents){%>
@RunAs(${component.names.realm}.ROLE_TIMEOUT)<%}%>
public class $className extends $module.names.stateTimeoutHandlerImpl {
  @Resource
  protected TimerService timerService;
  
  @Override
  public void registerTimer() {
    TimerConfig timerConfig = new TimerConfig(source, false);
    timerConfig.setPersistent(false);
    timerService.createIntervalTimer(0, stateTimeouts.getTimeoutCheckInterval(), timerConfig);
  }

  @Override  
  @Timeout
  public void processExpired$module.entity.names.instancesCap() {
    super.processExpired$module.entity.names.instancesCap();
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/ejb/${className}.java" %><% } %>
'''

common.stateMachine.module.stateTimeoutHandlerImpl = '''<% def className = module.names.stateTimeoutHandlerImpl; if(module.timeoutEnabled) { def controller = module.controller %>
$macros.header
package ${destModule.namespaces.core}.impl;

import java.util.Date;
import java.util.List;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.util.StringUtils;
import ${module.entity.manager.nameFull()};
import ${destModule.namespaces.core}.$controller.names.clazz;
import ${destModule.namespaces.core}.$module.names.stateTimeoutHandler;
import ${module.entity.nameFull()};
import ${destModule.namespaces.model}.$module.names.eventFactory;
import ${destModule.namespaces.model}.${module.capShortName}Timeouts;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.util.TimeUtils;

public abstract class $className implements $module.names.stateTimeoutHandler {
  protected final String source = StringUtils.formatSource(this);
  protected ${module.capShortName}Timeouts stateTimeouts;
  protected $module.entity.manager.names.clazz $module.entity.manager.names.instance;
  protected $controller.names.clazz $controller.names.instance;
  protected $module.names.eventFactory eventFactory;

  @Override  
  public void processExpired$module.entity.names.instancesCap() {
    List<$module.entity.names.clazz> expired$module.entity.names.instancesCap = ${module.entity.manager.names.instance}.findBy$module.stateTimeoutProp.capName(TimeUtils.now());
    for ($module.entity.names.clazz $module.entity.names.instance : expired$module.entity.names.instancesCap) {
      ${controller.names.instance}.process(eventFactory.newTimeoutEvent($module.entity.names.instance.${module.entity.idProp.getter}, $module.entity.names.instance.$module.stateProp.getter));
    }
  }

  @Inject
  public void setStateTimeouts(${module.capShortName}Timeouts stateTimeouts) {
    this.stateTimeouts = stateTimeouts;
  }

  @Inject
  public void set$module.entity.manager.name($module.entity.manager.names.clazz $module.entity.manager.names.instance) {
    this.$module.entity.manager.names.instance = $module.entity.manager.names.instance;
  }

  @Inject
  public void set$controller.names.clazz($controller.names.clazz $controller.names.instance) {
    this.$controller.names.instance = $controller.names.instance;
  }

  @Inject
  public void setEventFactory($module.names.eventFactory eventFactory) {
    this.eventFactory = eventFactory;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %><% } %>
'''

memory.stateMachine.module.stateTimeoutHandlerMem = '''<% def className = module.names.stateTimeoutHandlerMem; if(module.timeoutEnabled) { %>
$macros.header
package ${destModule.namespaces.core}.mem;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.enterprise.context.ApplicationScoped;

import ${destModule.namespaces.core}.impl.$module.names.stateTimeoutHandlerImpl;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;


@ApplicationScoped
@SupportsEnvironments(@Environment(executions = { LOCAL, MEMORY }))
@Controller
public class $className extends $module.names.stateTimeoutHandlerImpl {
  protected final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
  
  @Override
  public void registerTimer() {
    final Runnable timeout = new Runnable() {
      @Override
      public void run() {
        processExpired$module.entity.names.instancesCap();
      }
    };
    scheduler.scheduleAtFixedRate(timeout, 0, stateTimeouts.getTimeoutCheckInterval(), TimeUnit.MILLISECONDS);
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/mem/${className}.java" %><% } %>
'''

common.stateMachine.module.transitionExecutionResult = '''<% def className = module.names.transitionExecutionResult %>
$macros.header
package ${destModule.namespaces.model};

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import com.siemens.ra.cg.pl.common.base.model.Link;
import com.siemens.ra.cg.pl.common.base.ml.MLKey;
import com.siemens.ra.cg.pl.common.base.ml.MLKeyImpl;

import ${module.stateProp.typeEl.nameFull()};

/** Result object for procession of a transition in state machine $module.name. The object provides especially results action executions bound to a transition. */
public class $className<EVENT extends $module.names.event> {
  protected $module.stateProp.type fromState;
  protected $module.stateProp.type toState;
  protected EVENT event;
  protected ArrayList<Link<$module.names.actionType, Boolean>> actionResults = new ArrayList<>();
  protected $module.names.actionType failedAction = null;

  public $className($module.stateProp.type fromState, $module.stateProp.type toState, EVENT event) {
    this.fromState = fromState;
    this.toState = toState;
    this.event = event;
  }

  /** Add action result and return boolean result value in order to use the method in condition line */
  public boolean add($module.names.actionType actionType, boolean successfully) {
    actionResults.add(new Link<$module.names.actionType, Boolean>(actionType, successfully));
    if(!successfully) {
      this.failedAction = actionType;
    }
    return successfully;
  }

  public $module.stateProp.type getFromState() {
    return fromState;
  }

  public MLKey getFromStateAsMlKey() {
    return fromState != null ? fromState.buildMlKey() : null;
  }

  public $module.stateProp.type getToState() {
    return toState;
  }

  public MLKey getToStateAsMlKey() {
    return toState != null ? toState.buildMlKey() : null;
  }

  public EVENT getEvent() {
    return event;
  }

  public MLKey getEventTypeAsMlKey() {
    return event != null ? event.getType().buildMlKey() : null;
  }

  public List<Link<$module.names.actionType, Boolean>> getActionResults() {
    return actionResults;
  }

  public boolean isSuccessfully() {
    return failedAction == null;
  }

  public $module.names.actionType getFailedAction() {
    return failedAction;
  }

  public MLKey getFailedActionAsMlKey() {
    return failedAction != null ? event.getType().buildMlKey() : null;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.action.actionEvent = '''<% if(item.async) { def className= item.names.event; %>
$macros.header
package ${destModule.namespaces.model}.event;

import com.siemens.ra.cg.pl.common.base.messaging.impl.EventImpl;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import ${module.entity.nameFull()};
import ${destModule.namespaces.model}.$module.names.event;
import ${destModule.namespaces.model}.$module.names.actionType;
import ${module.stateProp.typeEl.nameFull()};

/** Event object for action $item.name */
public class $className extends EventImpl<${module.entity.names.clazz}> {
  private static final long serialVersionUID = 1L;
  private $module.names.event stateEvent;
  private $module.stateProp.type oldState;
  private $module.stateProp.type newState;

  public $item.names.event(${module.entity.names.clazz} object, ActionType type, String source, $module.names.event stateEvent, $module.stateProp.type oldState, $module.stateProp.type newState) {
    super(object, type, source, ${module.entity.names.clazz}.class);
    this.stateEvent = stateEvent;
    this.oldState =  oldState;
    this.newState = newState;
  }

  public $module.names.actionType getStateAction() {
    return ${module.names.actionType}.$item.names.literalInit;
  }

  public $module.stateProp.type getOldState() {
    return oldState;
  }

  public $module.stateProp.type getNewState() {
    return newState;
  }

  public $module.names.event getStateEvent() {
    return stateEvent;
  }

  @Override
  protected void fillToString(StringBuffer b) {
    super.fillToString(b);
    b.append(SEPARATOR);
    b.append("stateEvent=").append(stateEvent).append(SEPARATOR);
    b.append("oldState=").append(oldState).append(SEPARATOR);
    b.append("newState=").append(newState);
  }
  
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((newState == null) ? 0 : newState.hashCode());
    result = prime * result + ((oldState == null) ? 0 : oldState.hashCode());
    result = prime * result + ((stateEvent == null) ? 0 : stateEvent.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (!super.equals(obj))
      return false;
    if (getClass() != obj.getClass())
      return false;
    $className other = ($className) obj;
    if (newState != other.newState)
      return false;
    if (oldState != other.oldState)
      return false;
    if (stateEvent == null) {
      if (other.stateEvent != null)
        return false;
    } else if (!stateEvent.equals(other.stateEvent))
      return false;
    return true;
  }
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/event/${className}.java" %><% } %>
'''

common.stateMachine.action.actionEventReceiver = '''<% if(item.async) { %><% def className= "${item.names.event}Receiver" %>
$macros.header
package ${destModule.namespaces.integ}.receiver;

import static javax.enterprise.event.Reception.*;
import static javax.enterprise.event.TransactionPhase.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;

import com.siemens.ra.cg.pl.common.base.cdi.Receiver;
import ${destModule.namespaces.model}.event.$item.names.event;

/** Event receiver for JSE environment only of {@link $item.names.event} */
@ApplicationScoped
public class $className extends Receiver<${item.names.event}> {
  @Override
  public void onEvent(@Observes(during = AFTER_COMPLETION, notifyObserver = IF_EXISTS) $item.names.event event) {
    super.onEvent(event);
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/receiver/${className}.java" %><% } %>
'''

common.stateMachine.action.executor = '''<% if(!item.body && !item.async) { def className = item.names.clazz %>
$macros.header
package ${destModule.namespaces.core};

/** Executor for action $item.name of state machine $module.name */
public interface $className extends $module.names.actionExecutor {
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>
'''

common.stateMachine.action.executorImpl = '''<% if(!item.body && !item.async) { def className = item.names.impl %>
$macros.header
package ${destModule.namespaces.core}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${destModule.namespaces.model}.$module.names.actionType;
import ${destModule.namespaces.model}.$module.names.event;
import ${destModule.namespaces.core}.$item.names.clazz;

@Controller
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className implements $item.names.clazz {
  protected final XLogger log = XLoggerFactory.getXLogger(getClass());

  @Override
  public $module.names.actionType getType() {
    return $module.names.actionType.$item.underscoredName;
  }

  @Override
  public boolean execute($module.names.event event, $module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.context.names.clazz context) {
    log.debug("execute({},{},{},{})", event, $module.entity.names.instance, oldState, newState);
    boolean ret = true;
    //TODO to implement
    return ret;
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %><% } %>
'''

common.stateMachine.event.clazz = '''<% def className = item.names.clazz %>
$macros.header
package ${destModule.namespaces.model};

/** $item.capName event interface of state machine $module.name */
public interface $className extends $module.names.event { <% item.props.each { prop-> %>
  ${prop.description?"   /** $prop.description */":''}
  $prop.computedType get${prop.capName}();

  void set${prop.capName}($prop.computedType $prop.name);<% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.event.impl = '''<% def className = item.names.impl; def idProp = module.entity.idProp %>
$macros.header
package ${destModule.namespaces.model}.impl;

import ${module.stateProp.typeEl.nameFull()};
import ${destModule.namespaces.model}.${item.names.clazz};
import ${destModule.namespaces.model}.${module.names.eventType};

public class $className extends ${module.names.event}Impl implements $item.names.clazz {
  private static final long serialVersionUID = 1L;<% item.props.each { prop-> %>

  protected $prop.computedType $prop.name;<% } %>

  public $className() {
    super(${module.names.eventType}.$item.underscoredName);
  }<% if(!item.props) { %>

  public $className($idProp.type $idProp.uncapFullname) {
    super(${module.names.eventType}.$item.underscoredName, $idProp.uncapFullname);
  }<% } %>

  public $className($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState) {
    super(${module.names.eventType}.$item.underscoredName, $idProp.uncapFullname, expectedState);
  }<% if(item.props) { %>

  public $className($idProp.type $idProp.uncapFullname, $item.signatureFullConstr) {
    super(${module.names.eventType}.$item.underscoredName, $idProp.uncapFullname);<% item.props.each { prop-> %>
    this.$prop.name = $prop.name;<% } %>
  }

  public $className($idProp.type $idProp.uncapFullname, $module.stateProp.type expectedState, $item.signatureFullConstr) {
    super(${module.names.eventType}.$item.underscoredName, $idProp.uncapFullname, expectedState);<% item.props.each { prop-> %>
    this.$prop.name = $prop.name;<% } %>
  }<% item.props.each { prop-> %>

  @Override
  public $prop.computedType get${prop.capName}() {
    return $prop.name;
  }

  @Override
  public void set${prop.capName}($prop.computedType $prop.name) {
    this.$prop.name = $prop.name;
  }<% } }%>

  @Override
  protected void fillToString(StringBuffer b) {
    super.fillToString(b);
    b.append(SEPARATOR);<% item.props.each { prop-> if(prop.type.matches('(String|Boolean|Long|Integer)')) { %>
    b.append("$prop.name=").append($prop.name).append(SEPARATOR);<% } } %>
  }
  ${macros.apply(name: 'hashCodeAndEquals', className: className)}
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.state.eventProcessor = '''<% def className = item.names.eventProcessor %>
$macros.header
package ${destModule.namespaces.core};

import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${destModule.namespaces.model}.*;

/** Event processor for state '$item.name' of '$module.name'. */
public interface $className extends $module.names.stateEventProcessor {<% item.eventTransitions.each { etrs-> def event = etrs.event; %>

  $module.entity.names.clazz $event.uncapName($event.names.clazz event, $module.entity.names.clazz $module.entity.uncapName, $module.context.names.clazz context);<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %>
'''

common.stateMachine.state.eventProcessorImpl = '''<% def className = item.names.eventProcessorImpl %>
$macros.header
package ${destModule.namespaces.core}.impl;

import java.util.ArrayList;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;
import static ${destModule.namespaces.model}.$module.names.actionType.*;
import static ${module.stateProp.typeEl.nameFull()}.*;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Event;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import com.siemens.ra.cg.pl.common.base.model.ActionType;
import ${component.shared.namespaces.integ}.${component.names.qualifier};<%if(module.generatePermissionsForEvents){%>
import ${component.shared.namespaces.integ}.${component.names.realm};<% } %>
import ${module.stateProp.typeEl.nameFull()};
import ${module.entity.nameFull()};
import ${module.context.nameFull()};
import ${shared.namespaces.integ}.$module.shared.names.constants;
import ${destModule.namespaces.model}.*;<% if(module.conditions) { %>
import ${destModule.namespaces.model}.cond.impl.*;<% } %>
import ${destModule.namespaces.core}.*; <% item.actions.each { def action-> if(action.async) { %>
import ${destModule.namespaces.model}.event.$action.names.event;<% }} %>

/** Event processor for state '$item.name' of '$module.name'. */
@Controller
@ApplicationScoped
@SupportsEnvironments({
    @Environment(executions = { PRODUCTIVE }, runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
public class $className extends $module.names.stateEventProcessorImpl implements $item.names.eventProcessor {<% item.actions.each { def action-> if(!action.body) { if(action.async) { %>
  protected Event<${action.names.event}> ${action.uncapName}Publisher;<% } else { %>
  protected $action.names.clazz $action.names.instance;<% } %>
  <% } } %><% item.conditions.each { cond -> %>
  protected $cond.names.clazz $cond.names.instance;<% } %><% if (item.transitions) { %>

  @Override
  public $module.entity.names.clazz process($module.names.event event, $module.entity.names.clazz $module.entity.names.instance, $module.context.names.clazz context) {
    log.debug("process({},{})", event, $module.entity.names.instance);
    $module.entity.names.clazz ret;
    <% item.eventTransitions.each { etrs-> def event = etrs.event; %>if (event.getType().is$event.capName()) {
      ret = $event.uncapName(($event.names.clazz)event, $module.entity.names.instance, context);
    } else <% } %>{
      ret = super.process(event, $module.entity.names.instance, context);
    }
    return ret;
  }<% } %><% item.eventTransitions.each { etrs-> %>

  @Override
  public $module.entity.names.clazz $etrs.event.uncapName($etrs.event.names.clazz event, $module.entity.names.clazz $module.entity.names.instance, $module.context.names.clazz context) {
    log.debug("$etrs.event.uncapName({},{})", event, $module.entity.names.instance);<%if (item.getStateMachine().generatePermissionsForEvents){%>
    userInRoleConditionVerifier.evaluateConditionStrict(${component.names.realm}.ROLE_${etrs.event.underscoredName}, context);<%}; etrs.transition.conditionObjs.each { cond -> %>
    ${cond.names.instance}.evaluateConditionStrict($module.entity.names.instance, context);<% } %>
    <% if (etrs.actionEvent) { def elseCase = false; %>
    $module.entity.names.clazz ret;
    $module.stateProp.type oldState = ${module.entity.names.instance}.get$module.stateProp.capName();
    ArrayList<$module.names.transitionExecutionResult<?>> results = new ArrayList<>();
    $module.names.transitionExecutionResult<$etrs.event.names.clazz> result;
    <% etrs.transitions.each { def tr->
      if (tr.allActions) { def expr = tr.allActions.collect { def action->
      action.body || action.async?"result.add($action.underscoredName, $action.uncapName(event, $module.entity.names.instance, oldState, $tr.state.underscoredName, context))":"result.add($action.underscoredName, ${action.names.instance}.execute(event, $module.entity.names.instance, oldState, $tr.state.underscoredName, context))" }.join(' &&         ')
    %>if (results.add(result = new $module.names.transitionExecutionResult<>(oldState, $tr.state.underscoredName, event)) && 
        $expr) {<% if(module.timeoutEnabled) { if(tr.state.timeoutEnabled) { %>
      changeStateTimeout($module.entity.uncapName, stateTimeouts.get${tr.state.capName}Timeout(), context);<% } else { %>
      clearStateTimeout($module.entity.uncapName, context);<% } } %>
      ret = update$module.stateProp.type($module.entity.uncapName, oldState, $tr.state.underscoredName, event.getType(), context);
      traceValidFlow(event, $module.entity.names.instance, results, context);
    } else <% } else { elseCase = true; %>{//here<% if(module.timeoutEnabled) { if(tr.state.timeoutEnabled) { %>
      changeStateTimeout($module.entity.uncapName, stateTimeouts.get${tr.state.capName}Timeout(), context); <% } else { %>
      clearStateTimeout($module.entity.uncapName, context); <% } } %>
      ret = update$module.stateProp.type($module.entity.uncapName, oldState, $tr.state.underscoredName, event.getType(), context);
      traceValidFlow(event, $module.entity.names.instance, results, context);
    }<% } %><% } %><% if(!elseCase) { %>{
      ret = super.processNoValidFlow(event, $module.entity.names.instance, results, context);
    }<% } } else { def tr = etrs.transition %><% if(module.timeoutEnabled) { if(tr.state.timeoutEnabled) { %>changeStateTimeout($module.entity.uncapName, stateTimeouts.get${tr.state.capName}Timeout(), context);<% } else { %>clearStateTimeout($module.entity.uncapName, context);<% } } %>
    $module.entity.names.clazz ret = update$module.stateProp.type($module.entity.uncapName, ${module.entity.names.instance}.get$module.stateProp.capName(), $tr.state.underscoredName, event.getType()<%if(!tr.fireEvent){%>, false<%}%>, context);<%}%>
    return ret;
  }<% } %><% item.actions.each { def action-> if(action.body) { %>

  protected boolean $action.uncapName($module.names.event event, $module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.context.names.clazz context) {
    log.debug("$action.uncapName({},{},{},{},{})", event, $module.entity.names.instance, oldState, newState, context);
    $action.body
  }<% } else if(action.async) { %> 
  
  protected boolean $action.uncapName($module.names.event event, $module.entity.names.clazz $module.entity.names.instance, $module.stateProp.type oldState, $module.stateProp.type newState, $module.context.names.clazz context) {
    log.debug("$action.uncapName({},{},{},{},{})", event, $module.entity.names.instance, oldState, newState, context);
    ${action.uncapName}Publisher.fire(new $action.names.event($module.entity.names.instance, ActionType.TRIGGER, source, event, oldState, newState));
    return true;
  }<% } } %><% item.actions.each { def action-> if(!action.body) { if(action.async) { %>
  
  @Inject
  public void set${action.capName}Publisher(@$component.names.qualifier @Backend Event<${action.names.event}> ${action.uncapName}Publisher) {
    this.${action.uncapName}Publisher = ${action.uncapName}Publisher;
  }<% } else { %>
  
  @Inject
  public void set$action.names.clazz($action.names.clazz $action.names.instance) {
    this.$action.names.instance = $action.names.instance;
  }<% } } } %><% item.conditions.each { cond -> %>

  @Inject
  public void set$cond.names.clazz($cond.names.clazz $cond.names.instance) {
    this.$cond.names.instance = $cond.names.instance;
  }<% } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %>
'''

common.stateMachine.state.metaState = '''<% def className = item.names.metaState %>
$macros.header
package ${destModule.namespaces.model}.meta;

import static ${destModule.namespaces.model}.$module.names.eventType.*;

import java.util.List;
import java.util.ArrayList;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import ${module.stateProp.typeEl.nameFull()};
import ${destModule.namespaces.model}.$module.names.eventType;
import ${module.entity.nameFull()};
import ${module.context.nameFull()};<% if(module.conditions) { %>
import ${destModule.namespaces.model}.cond.impl.*;<% } %><%if(module.generatePermissionsForEvents){%>
import ${component.shared.namespaces.integ}.${component.names.realm};<% } %>

import ${module.conditionEntity.nameFull()};

/** Static information of state $item.name of state machine $module.name */
@ApplicationScoped
public class $className extends $module.names.metaState {
  private static final long serialVersionUID = 1L;
  <%def conditions = item.eventTransitions.collect { etrs -> etrs.transition.conditionObjs }.flatten() as Set
  conditions.each { cond -> %>
  private ${cond.names.clazz} ${cond.uncapName}Verifier;<% } %> 

  public $className() {
    super($module.stateProp.type.$item.underscoredName, findStateEvents());<% item.toBeNotified.each { toBeNotified ->%> 
    ${toBeNotified}ToBeNotified = true;<% } %>
  }
  
  private static List<$module.names.eventType> findStateEvents() {
    List<$module.names.eventType> ret = new ArrayList<$module.names.eventType>();
    <% item.eventTransitions.each { %>
    ret.add($it.event.underscoredName);<% } %>
    return ret;
  }

  @Override
  public List<$module.names.eventType> findPossibleEvents($module.entity.names.clazz $module.entity.names.instance, $module.context.names.clazz context) {
    List<$module.names.eventType> ret = new ArrayList<$module.names.eventType>();
    <% item.eventTransitions.each { etrs -> 
      def condStr
      def groupStr
      if (etrs.transition.conditionObjs) { 
        condStr = etrs.transition.conditionObjs.collect { cond -> "${cond.uncapName}Verifier.evaluateCondition($module.entity.names.instance, context)" }.join(' &&\\n        ') 
      }
      if (etrs.transition.groupObjs) { 
        groupStr = etrs.transition.groupObjs.collect { group -> "userInRoleConditionVerifier.evaluateCondition(${component.names.realm}.ROLE_${etrs.event.underscoredName}, context)" }.join(' &&\\n        ') 
      }

      def strList = [groupStr, condStr]
      def str = strList.findAll().join(' &&\\n        ')

      if (str) { 
    %>
    if ($str) {
      ret.add($etrs.event.underscoredName);
    }<% } else { %>
    ret.add($etrs.event.underscoredName);<% } } %>
    return ret;
  }

  <%conditions.each { cond -> %>
  @Inject
  public void set${cond.capName}Verifier(${cond.capName}Verifier ${cond.uncapName}Verifier) {
    this.${cond.uncapName}Verifier = ${cond.uncapName}Verifier;
  }
  <% } %>
}
<% ret.path = "${shared.javaSrcGen}/${destModule.namespaces.model.dotsAsPath()}/meta/${className}.java" %>'''

common.stateMachine.condition.conditionHandler = '''<% if(!item.body) { def className = item.names.clazz %>
$macros.header
package ${destModule.namespaces.model}.cond.impl;

import javax.enterprise.context.ApplicationScoped;

import ${shared.namespaces.integ}.${shared.names.ml};
import ${module.conditionEntity.nameFull()};
import ${module.context.nameFull()};
import com.siemens.ra.cg.pl.common.base.cond.ConditionVerifierAbstract;
import com.siemens.ra.cg.pl.common.base.integ.RoleValidator;
import com.siemens.ra.cg.pl.common.base.model.SessionPrincipal;
import com.siemens.ra.cg.pl.common.base.annotations.Controller;

@Controller
@ApplicationScoped
public class $className extends ConditionVerifierAbstract<${module.conditionEntity.name}, $module.context.names.clazz> {
  private static final long serialVersionUID = 1L;
  
  @Override
  protected String getMlBase() {
    return ${shared.names.ml}.ML_BASE;
  }
  
  @Override
  protected String getExceptionKey() {
    return ${shared.names.ml}.${item.names.failMl};
  }
  
  @Override
  public boolean evaluateCondition(${module.conditionEntity.name} ${module.conditionEntity.names.instance}, $module.context.names.clazz context) {
    log.debug("evaluateCondition({}), sessionPrincipal = {}", ${module.conditionEntity.names.instance}, sessionPrincipal);
    
    // TODO implement me
    return true;
  }
}
<% ret.overwrite = false; ret.path = "${shared.javaSrc}/${destModule.namespaces.model.dotsAsPath()}/cond/impl/${className}.java" %><% } %>
'''

common.stateMachine.condition.conditionHandlerTestBase = '''<% if(!item.body) { def className = "${item.names.clazz}TestBase" %>
$macros.header
package ${destModule.namespaces.model}.cond.impl;

import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;
import static org.junit.Assert.*;

import org.junit.Test;
import org.mockito.Mock;

import ${shared.namespaces.integ}.${shared.names.ml}Base;
import ${module.conditionEntity.nameFull()};
import com.siemens.ra.cg.pl.common.base.integ.RoleValidator;
import com.siemens.ra.cg.pl.common.base.model.SessionPrincipal;

public abstract class $className {
  
  protected ${item.names.clazz} verifier;
  
  @Mock
  protected RoleValidator roleValidator;
  @Mock
  protected SessionPrincipal sessionPrincipal;
  
  public void setUp() {
    verifier = new ${item.names.clazz}();
    verifier.setSessionPrincipal(sessionPrincipal);
    verifier.setRoleValidator(roleValidator);
  }

  @Test
  public void usesCorrectExceptionKey() {
    // when
    String exceptionKey = verifier.getExceptionKey();
    // then
    assertThat(exceptionKey, is(${shared.names.ml}Base.${item.names.failMl}));
  }
}
<% ret.path = "${shared.javaTestSrcGen}/${destModule.namespaces.model.dotsAsPath()}/cond/impl/${className}.java" %><% } %>
'''

common.stateMachine.condition.conditionHandlerTest = '''<% if(!item.body) { def className = "${item.names.clazz}Test" %>
$macros.header
package ${destModule.namespaces.model}.cond.impl;

import org.junit.Before;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class $className extends ${item.names.clazz}TestBase {

  @Override
  @Before
  public void setUp() {
    super.setUp();
    // additional setup
  }

  // tests
}
<% ret.overwrite = false; ret.path = "${shared.javaTestSrc}/${destModule.namespaces.model.dotsAsPath()}/cond/impl/${className}.java" %><% } %>
'''

common.ui.view.presenter = '''<% def presenter = item.presenter; def className = "${presenter.names.clazz}" %>
$macros.header
package ${destModule.namespace}.$presenter.namespace;

import java.util.Date;

import com.siemens.ra.cg.pl.common.base.annotations.Presenter;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped;

import com.siemens.ra.cg.pl.uif.event.*;

/** Presenter implementation for ${item.name}. */
@RootScoped
@Presenter
public class $className extends ${presenter.names.clazz}Base {<% item.controls.each { def control-> control.operations.each { def op -> %>

  @Override
  public void $op.nameExternal($op.signatureExternal) {
    //TODO: implement $op.nameExternal($op.signatureExternal)
  }<% } } %>
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${presenter.namespace.dotsAsPath()}/${className}.java" %>
'''

common.ui.view.presenterBase = '''<% def presenter = item.presenter; def className = presenter.names.base %>
$macros.header
package ${destModule.namespace}.$presenter.namespace;

import java.util.Date;

import ${destModule.namespace}.${item.namespace}.*;
import com.siemens.ra.cg.pl.uif.event.*;
import com.siemens.ra.cg.pl.uif.model.*;
import com.siemens.ra.cg.pl.uif.mvp.Presenter;

/** Base presenter implementation for ${item.name}. */
public abstract class $className extends Presenter<${item.names.clazz}> {<% item.controls.each { def control-> control.operations.each { def op -> %>

  public abstract void $op.nameExternal($op.signatureExternal);<% } } %> 
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${presenter.namespace.dotsAsPath()}/${className}.java" %>
'''

common.ui.view.presenterBaseTest = '''<% def presenter = item.presenter; def className = presenter.names.testBase %>
$macros.header
package ${destModule.namespace}.$presenter.namespace;

import static com.siemens.ra.cg.pl.common.base.mockito.MockitoCg.*;
import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;
import static org.hamcrest.MatcherAssert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;

import com.siemens.ra.cg.pl.uif.mvp.PresenterTestCase;
import com.siemens.ra.cg.pl.uif.widget.*;

import ${destModule.namespace}.${item.namespace}.*;

public class $className extends PresenterTestCase<$presenter.names.clazz> {
  @Mock
  protected $item.names.clazz view;
  <% item.controls.each { def control-> if (!control.static) { %>protected $control.widgetInterface $control.fieldName;
  <% } } %>
  @Override
  protected $presenter.names.clazz instantiatePresenterUnderTest() {
    return spy(new $presenter.names.clazz());
  }

  @Override
  protected void mockPresenterDependencies() {
    super.mockPresenterDependencies();
    presenter.setView(view);
  }

  @Override
  protected void mockViewDependencies() {
    <% item.controls.each { def control-> if (!control.static) { %>$control.fieldName = mock(${control.widgetInterface}.class, RETURNS_SMART_DEFAULTS);
    when(view.$control.getter).thenReturn($control.fieldName);
    <% } } %>
  }

  @Test
  public void defaultConstructorForCoverage() throws Exception {
    assertThat(new $presenter.names.clazz(), is(notNullValue()));
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${presenter.namespace.dotsAsPath()}/${className}.java" %>
'''

common.ui.view.presenterTest = '''<% def presenter = item.presenter; def className = presenter.names.test %>
$macros.header
package ${destModule.namespace}.$presenter.namespace;

import org.junit.*;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class $className extends $presenter.names.testBase {
  @Before
  @Override
  public void setUp() {
    super.setUp();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${presenter.namespace.dotsAsPath()}/${className}.java" %>
'''

common.ui.view.viewInterface = '''<% def className = item.names.clazz %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/** Interface of ${item.name}. */
public interface $className extends ${className}Base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

common.ui.view.viewInterfaceBase = '''<% def className = item.names.base; def baseClass = item.dialog ? 'DialogViewInterface' : 'ViewInterface' %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import com.siemens.ra.cg.pl.uif.widget.*;

/** Base interface of ${item.name}. */
public interface $className extends $baseClass {<% item.controls.each { def control-> if (!control.static) { %>
  $control.widgetInterface ${control.getter};
  <% } } %> 
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.dialogDriver = '''<% if (item.dialog) { def className = "${item.names.driver}"; def viewClassName = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/** Driver for {@link $viewClassName} view. */
public class $className extends ${item.names.driverBase} {
  public $className() {
    super();
  }
}
<% ret.overwrite = true; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.dialogDriverBase = '''<% if (item.dialog) { def className = "${item.names.driverBase}"; def viewClassName = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.OnEventThread;
import com.siemens.ra.cg.pl.common.base.annotations.OnEventThread.CallType;
import com.siemens.ra.cg.pl.uif.guido.driver.ViewDriver;

/** Base class for {@link $viewClassName} driver. */
public class $className extends ViewDriver<$viewClassName> {
  private ${item.names.clazz}ViewDriver contentView;

  public $className() {
    super(${viewClassName}.class);
  }

  @OnEventThread(CallType.SYNC)
  public ${item.names.clazz}ViewDriver contentView() {
    if (contentView == null) {
      contentView = newDriver(new ${item.names.clazz}ViewDriver(view().contentView));
    }
    return contentView;
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.dialogGuido = '''<% if (item.dialog) { def className = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.View;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped.RootType;

import ${module.namespace}.${item.presenter.namespace}.*;
import ${module.namespace}.${item.namespace}.*;

/** Guido implementation of ${item.name}. */
@RootScoped(RootType.NEW)
@View
public class $className extends ${item.names.clazz}GuidoBase {

  public $className() {
    super();
  }

  @Override
  protected void initWidgets() {
    super.initWidgets();
  }

  @Override
  protected void initEventHandling() {
    super.initEventHandling();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.dialogGuidoBase = '''<% if (item.dialog) { def className = "${item.names.clazz}GuidoBase" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import javax.inject.Inject;

import ${destModule.namespace}.${item.namespace}.*;

import com.siemens.ra.cg.pl.uif.guido.widget.DialogView;

/** Base Guido implementation of ${item.name}. */
public class $className extends DialogView {
  public static final String ID = ${item.names.clazz}Guido.class.getName();

  protected ${item.names.clazz}Guido contentView;

  public $className() {
    super();
  }

  @Override
  protected void postViewCreated() {
    super.postViewCreated();
    initWidgets();
    initEventHandling();
  }

  protected void initWidgets() {
    addContent(contentView);
  }

  protected void initEventHandling() {
  }

  @Inject
  public void setContentView(${item.names.clazz}Guido contentView) {
    this.contentView = contentView;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.dialogGuidoBaseTest = '''<% if (item.dialog) { def viewClassName = "${item.names.clazz}Guido"; def contentViewClassName = "${item.names.clazz}Guido"; def className = "${viewClassName}TestBase" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;
import static org.hamcrest.MatcherAssert.*;
import static org.mockito.Mockito.*;

import org.junit.*;
import org.mockito.*;

import com.siemens.ra.cg.pl.uif.guido.test.*;

public abstract class $className extends GuidoViewTestCase<$viewClassName> {

  @Mock
  protected $contentViewClassName contentView;

  @Before
  @Override
  public void setUp() {
    super.setUp();
  }

  @Override
  protected $viewClassName instantiateViewUnderTest() {
    return spy(new $viewClassName());
  }

  @Override
  protected void beforeViewCreated() {
    super.beforeViewCreated();
    view.setContentView(contentView);
  }

  @Test
  public void callsInitMethodsIfCreated() throws Exception {
    // view is created in setUp phase
    InOrder inOrder = inOrder(view);
    inOrder.verify(view).initWidgets();
    inOrder.verify(view).addContent(contentView);
    inOrder.verify(view).initEventHandling();
  }

  @Test
  public void defaultConstructorForCoverage() throws Exception {
    assertThat(new ${viewClassName}(), is(notNullValue()));
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.dialogGuidoTest = '''<% if (item.dialog) { def viewClassName = "${item.names.clazz}Guido"; def className = "${viewClassName}Test" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import org.junit.*;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class $className extends ${className}Base {
  @Before
  @Override
  public void setUp() {
    super.setUp();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

guido.ui.view.viewDriverGuido = '''<% def className = "${item.names.driver}"; def viewClassName = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

/** Driver for {@link $viewClassName} view. */
public class $className extends ${item.names.driverBase} {
  public $className() {
    super();
  }

  public $className($viewClassName view) {
    super(view);
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.viewDriverGuidoBase = '''<% def className = "${item.names.driverBase}"; def viewClassName = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.util.Date;

import com.siemens.ra.cg.pl.common.base.annotations.OnEventThread;
import com.siemens.ra.cg.pl.common.base.annotations.OnEventThread.CallType;
import com.siemens.ra.cg.pl.uif.guido.driver.*;

/** Base class for {@link $viewClassName} driver. */
public class $className extends ViewDriver<$viewClassName> {
  <% item.controls.each { def control -> if (!control.static) { def widgetType = macros.guidWidgets[control.widgetType] %>protected ${widgetType}Driver ${control.fieldName};
  <% } } %>
  public $className() {
    super(${viewClassName}.class);
  }

  public $className($viewClassName view) {
    super(view);
  }
  <% item.controls.each { def control -> if (!control.static) { def widgetType = macros.guidWidgets[control.widgetType] %>
  public ${widgetType}Driver $control.fieldName() {
    if ($control.fieldName == null) {
      $control.fieldName = driverFactory().new${widgetType}Driver(view().$control.fieldName);
    }
    return $control.fieldName;
  }
  <% } } %>
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.guido = '''<% def className = "${item.names.clazz}Guido" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.View;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped;

import ${module.namespace}.${item.presenter.namespace}.*;
import ${module.namespace}.${item.namespace}.*;

/** Guido implementation of ${item.name}. */
@RootScoped
@View
public class $className extends ${item.names.clazz}GuidoBase {

  public $className() {
    super();
  }

  @Override
  protected void initWidgets() {
    super.initWidgets();
  }

  @Override
  protected void initEventHandling() {
    super.initEventHandling();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.guidoBase = '''<% def className = "${item.names.clazz}GuidoBase"; def baseClass = item.dialog ? 'DialogContentView' : 'BaseView' %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import java.util.Date;

import javax.inject.Inject;

import com.siemens.ra.cg.pl.uif.event.*;
import com.siemens.ra.cg.pl.uif.model.*;
import com.siemens.ra.cg.pl.uif.widget.*;

import ${module.namespace}.${item.presenter.namespace}.*;
import ${module.namespace}.${item.namespace}.*;

import com.siemens.ra.cg.pl.uif.guido.widget.BaseView;
import com.siemens.ra.cg.pl.uif.guido.widget.DialogContentView;
import com.siemens.ra.cg.pl.uif.guido.event.*;

/** Base Guido implementation of ${item.name}. */
public abstract class $className extends $baseClass implements $item.names.clazz {
  public static final String ID = ${item.names.clazz}Guido.class.getName();

  <% item.controls.each { def control-> if (control.ml) { %>
  static final String ${control.names.mlKeyConstant} = "$control.names.mlKey";<% } } %>
  <% item.controls.each { def control-> def widgetType = macros.guidWidgets[control.widgetType] %>protected com.siemens.ra.cg.pl.uif.guido.widget.$widgetType ${control.fieldName};
  <% } %>
  protected $item.presenter.names.clazz presenter;

  public $className() {
    super();
  }

  @Override
  protected void postViewCreated() {
    super.postViewCreated();
    initWidgets();
    initEventHandling();
    presenter.postViewCreated();
  }

  protected void initWidgets() {<% item.controls.each { def control-> def widgetType = macros.guidWidgets[control.widgetType] %>
    ${control.fieldName} = widgetFactory().new$widgetType(viewId, "${control.fieldName}");<% if (control.ml) { %>
    ${control.fieldName}.setTextML(${control.names.mlKeyConstant});<% } } %>
  }

  protected void initEventHandling() {<% item.controls.each { def control-> control.operations.each { def op -> def eventType = macros.guidoEvents[control.widgetType][op.name] %>
    ${control.fieldName}.add${eventType}Listener(new GuidoEventListener() {
      <% if (op.name == 'OnChange') { %>@SuppressWarnings("unchecked")<% } %> 
      @Override
      public void handleEvent(GuidoEvent event) {
        presenter.${op.nameExternal}(((${op.eventType}) event));
      }
    });<% } } %> 
  }
  <% item.controls.each { def control-> if (!control.static) { %>
  @Override
  public $control.widgetInterface ${control.getter} {
    return ${control.fieldName};
  }
  <% } } %> 
  @Inject
  public void setPresenter($item.presenter.names.clazz presenter) {
    this.presenter = presenter;
    presenter.setView(this);
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.guidoBaseTest = '''<% def viewClassName = "${item.names.clazz}Guido"; def className = "${viewClassName}TestBase" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import static com.siemens.ra.cg.pl.common.base.matcher.BasicMatchers.*;
import static org.hamcrest.MatcherAssert.*;
import static org.mockito.Mockito.*;

import java.util.Date;

import org.junit.*;
import org.mockito.*;

import com.siemens.ra.cg.pl.uif.guido.test.*;
import com.siemens.ra.cg.pl.uif.event.*;
import com.siemens.ra.cg.pl.uif.model.*;
import com.siemens.ra.cg.pl.uif.widget.*;

import ${module.namespace}.${item.presenter.namespace}.*;

public abstract class $className extends GuidoViewTestCase<$viewClassName> {

  @Mock
  protected $item.presenter.names.clazz presenter;

  @Before
  @Override
  public void setUp() {
    super.setUp();
  }

  @Override
  protected $viewClassName instantiateViewUnderTest() {
    return spy(new $viewClassName());
  }

  @Override
  protected void beforeViewCreated() {
    super.beforeViewCreated();
    view.setPresenter(presenter);
  }

  @Override
  protected void afterViewCreated() {
  }

  @Test
  public void registersItselfAtPresenter() throws Exception {
    verify(presenter).setView(view);
  }
  
  @Test
  public void callsInitMethodsIfCreated() throws Exception {
    // view is created in setUp phase
    InOrder inOrder = inOrder(view, presenter);
    inOrder.verify(view).initWidgets();
    inOrder.verify(view).initEventHandling();
    inOrder.verify(presenter).postViewCreated();
  }
  
  @Test
  public void initializesMlTexts() throws Exception {<% item.controls.each { def control-> if (control.ml) { %>
    assertThat(view.${control.fieldName}.getText(), is(${viewClassName}.$control.names.mlKeyConstant));<% } } %>
  }
  <% item.controls.each { def control-> control.operations.each { def op -> def guidoEventClass = macros.guidoEvents[control.widgetType][op.name]+"Event" %>
  @Test
  public void ${control.fieldName}${guidoEventClass}IsForwardedToPresenter() throws Exception {
    // when
    <% if (op.name == 'OnChange') { %>@SuppressWarnings("unchecked")<% } %>
    ${op.eventType} event = testEvents().eventReceived(view.${control.fieldName}, ${op.eventTypeRawType}.class);
    // then
    verify(presenter).${op.nameExternal}(event);
  }
  <% } } %> 
  @Test
  public void defaultConstructorForCoverage() throws Exception {
    assertThat(new ${viewClassName}(), is(notNullValue()));
  }

  @Test
  public void implementsViewInterface() throws Exception {<% item.controls.each { def control-> if (!control.static) { %>
    assertThat(view.${control.getter}, is(notNullValue()));
    assertThat(view.${control.getter}, is(($control.widgetInterface) view.${control.fieldName}));
    <% } } %> 
  }
}
<% ret.path = "${destModule.javaTestSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

guido.ui.view.guidoTest = '''<% def viewClassName = "${item.names.clazz}Guido"; def className = "${viewClassName}Test" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import org.junit.*;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class $className extends ${className}Base {
  @Before
  @Override
  public void setUp() {
    super.setUp();
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaTestSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %>
'''

aal.backend.module.cdiToAal = '''<% def aalEntities = module.entities.findAll {it.aal}
def aalContainers = module.containers.findAll{it.aal} %><% if(aalEntities || aalContainers) { %><% def className = "${module.capShortName}CdiToAal" %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.event.Observes;
import javax.ejb.Stateless;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.aal.integ.CdiToAalBase;
import com.siemens.ra.cg.pl.common.base.annotations.Backend;
import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;
import ${component.namespaces.integ}.$component.names.qualifier;
import ${module.namespaces.model}.event.*;

/** Cdi to Aal bridge for '${module.name}' */
@SupportsEnvironments(@Environment(runtimes = { SERVER }))
@Stateless
public class $className extends CdiToAalBase {<% aalEntities.each { entity-> if(entity.event) { %>

  public void on$entity.names.event(@Observes @$component.names.qualifier @Backend $entity.names.event event) {
    super.onEvent(event);
  }<% } } %>
  <% aalContainers.each { container-> if(container.event) { %>
  public void on$container.names.event(@Observes @$component.names.qualifier @Backend $container.names.event event) {
    super.onEvent(event);
  }<% } } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

xml.backend.module.cdiBeans = '''<% if(module.containers) { %><% def className = "${module.names.classPrefix}${facet.name.capitalize()}CdiBeans" %>
$macros.header
package ${destModule.namespaces.integ};

import java.util.ArrayList;
import java.util.List;

import com.siemens.ra.cg.pl.common.base.cdi.CdiConfiguration;
import com.siemens.ra.cg.pl.common.base.util.CollectionUtils;
import ${destModule.namespaces.core}.*;


/** Definition of CDI beans for '$module.name', in order to avoid scanning */
public class $className implements CdiConfiguration {

  @Override
  public List<Class<?>> getContainerClasses() {
    ArrayList<Class<?>> ret = new ArrayList<>();<% module.containers.each { container-> if (container.xml) { %>
    ret.add(${container.names.clazz}XmlConverter.class);<% } } %>
    ret.add(${module.names.xmlConverter}.class);
    return ret;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/${className}.java" %><% } %>'''

xml.backend.module.xmlConverter = '''<% if(module.entities) { %><% def className = "${module.names.xmlConverter}" %>
$macros.header
package ${destModule.namespaces.core};

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

/** Xml converter for types of '$module.name' */
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@ApplicationScoped
public class $className extends ${module.names.xmlConverter}Base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>'''

xml.backend.module.xmlConverterBase = '''<% if(module.entities) { %><% def className = "${module.names.xmlConverter}Base" %>
$macros.header
package ${destModule.namespaces.core};

import javax.enterprise.inject.Alternative;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

/** Base of Xml converter for types of '$module.name' */
@Alternative
public abstract class $className {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());<% module.shared.enums.each { t-> if(t.xml) { %>

  public ${t.nameFull()} convertFromXml(${facet.namespaceXmlSchema}.$t.nameXml from) {
    ${t.nameFull()} ret = from != null ? ${t.nameFull()}.valueOf(from.name()) : null;
    return ret;
  }

  public ${facet.namespaceXmlSchema}.$t.nameXml convertToXml(${t.nameFull()} from) {
    ${facet.namespaceXmlSchema}.$t.nameXml ret = ${facet.namespaceXmlSchema}.${t.nameXml}.valueOf(from.name());
    return ret;
  }<% } } %><% module.enums.each { t-> if(t.xml) { %>

  public ${t.nameFull()} convertFromXml(${facet.namespaceXmlSchema}.$t.nameXml from) {
    ${t.nameFull()} ret = from != null ? ${t.nameFull()}.valueOf(from.name()) : null;
    return ret;
  }

  public ${facet.namespaceXmlSchema}.$t.nameXml convertToXml(${t.nameFull()} from) {
    ${facet.namespaceXmlSchema}.$t.nameXml ret = ${facet.namespaceXmlSchema}.${t.nameXml}.valueOf(from.name());
    return ret;
  }<% } } %><% [module.basicTypes, module.entities].each { it.each { t-> if(t.xml) { %><% def raw = t.props.find { prop-> prop.xml && prop.multi && prop.typeRef.typeBasicType }; if(t.virtual) { %>
  <% if(raw) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public void fillFromXml(${t.nameFull('bean')} toFill, ${facet.namespaceXmlSchema}.$t.nameXml from) {
    if (from != null) {<% if(t.superUnit) { %>
      fillFromXml((${t.superUnit.nameFull('bean')})toFill, from);<% } %><% t.props.each { prop-> if(prop.xml) { %><% if(prop.multi || (prop.typeRef.typeEntity && prop.opposite)) { if(prop.multi) { %>
      toFill.set$prop.capName(${prop.typeRef.typeBasicType?'(List)':''}convert${prop.type}sFromXml(from.get${prop.nameXml.capitalize()}()));<% } else { %><% } %>
      <% } else if(prop.typeEl) { %>
      toFill.set$prop.capName(convertFromXml(from.$prop.getter));<% } else { %>
      toFill.set$prop.capName(from.$prop.getter);<% } %><% } } %>
    }
  }

  public void fillToXml(${facet.namespaceXmlSchema}.$t.nameXml toFill, ${t.nameFull()} from) {
    if (from != null) {<% if(t.superUnit) { %>
      fillToXml((${facet.namespaceXmlSchema}.$t.superUnit.nameXml)toFill, from);<% } %><% t.props.each { prop-> if(prop.xml) { %><% if(prop.multi || (prop.typeRef.typeEntity && prop.opposite)) { %>
      <% } else if(prop.typeEl) { %>
      toFill.set$prop.capName(convertToXml(from.$prop.getter));<% } else { %>
      toFill.set$prop.capName(from.$prop.getter);<% } %><% } } %>
    }
  }<% } else { %>
  <% if(raw) { %>
  @SuppressWarnings({ "rawtypes", "unchecked" })<% } %>
  public ${t.nameFull('bean')} convertFromXml(${facet.namespaceXmlSchema}.$t.nameXml from) {
    if (from == null) {
      return null;
    }

    ${t.nameFull('bean')} ret = new ${t.nameFull('bean')}();<% if(t.superUnit) { %>
    fillFromXml(ret, from);<% } %><% t.props.each { prop-> if(prop.xml) { %><% if(prop.multi || (prop.typeRef.typeEntity && prop.opposite)) { if(prop.multi) { %>
    ret.set$prop.capName(${prop.typeRef.typeBasicType?'(List)':''}convert${prop.type}sFromXml(from.get${prop.nameXml.capitalize()}()));<% } else { %><% } %>
    <% } else if(prop.typeEl) { %>
    ret.set$prop.capName(convertFromXml(from.$prop.getter));<% } else { %>
    ret.set$prop.capName(from.$prop.getter);<% } %><% } } %>
    return ret;
  }

  public ${facet.namespaceXmlSchema}.$t.nameXml convertToXml(${t.nameFull()} from) {
    if (from == null) {
      return null;
    }

    ${facet.namespaceXmlSchema}.$t.nameXml ret = new ${facet.namespaceXmlSchema}.$t.nameXml();<% if(t.superUnit) { %>
    fillToXml(ret, from);<% } %><% t.props.each { prop-> if(prop.xml) { %><% if(prop.multi || (prop.typeRef.typeEntity)) { %>
    <% } else if(prop.typeEl) { %>
    ret.set$prop.capName(convertToXml(from.$prop.getter));<% } else { %>
    ret.set$prop.capName(from.$prop.getter);<% } %><% } } %>
    return ret;
  }<% } } } } %>
  //resolvers
  <% [module.enums].each { it.each { t-> if(t.xml) { %><% if(!t.virtual) { %>

  public List<${facet.namespaceXmlSchema}.$t.nameXml> convert${t.names.clazz}sToXml(List<${t.nameFull()}> items) {
    ArrayList<${facet.namespaceXmlSchema}.$t.nameXml> ret = new ArrayList<>();
    for(${t.nameFull()} item : items) {
      ret.add(convertToXml(item));
    }
    return ret;
  }

  public List<${t.nameFull()}> convert${t.names.clazz}sFromXml(List<${facet.namespaceXmlSchema}.$t.nameXml> items) {
    ArrayList<${t.nameFull()}> ret = new ArrayList<>();
    for(${facet.namespaceXmlSchema}.$t.nameXml item : items) {
      ret.add(convertFromXml(item));
    }
    return ret;
  }<% } } } } %><% [module.basicTypes, module.entities].each { it.each { t-> if(t.xml) { %><% if(!t.virtual) { %>

  public List<${facet.namespaceXmlSchema}.$t.nameXml> convert${t.names.clazz}sToXml(List<${t.nameFull('bean')}> items) {
    ArrayList<${facet.namespaceXmlSchema}.$t.nameXml> ret = new ArrayList<>();
    for(${t.nameFull('bean')} item : items) {
      ret.add(convertToXml(item));
    }
    return ret;
  }

  public List<${t.nameFull('bean')}> convert${t.names.clazz}sFromXml(List<${facet.namespaceXmlSchema}.$t.nameXml> items) {
    ArrayList<${t.nameFull('bean')}> ret = new ArrayList<>();
    for(${facet.namespaceXmlSchema}.$t.nameXml item : items) {
      ret.add(convertFromXml(item));
    }
    return ret;
  }<% } } } } %>
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %><% } %>'''

xml.backend.container.containerImportDataMdb = '''<% if(item.controller.asyncImport) { %><% def className = item.names.importDataMdb %>
$macros.header
package ${destModule.namespaces.integ}.ejb;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.MessageListener;

import com.siemens.ra.cg.pl.common.ejb.messaging.SingleTypeEventListenerBridgeByJms;
import ${item.xmlController.nameFull()};
import ${shared.namespaces.integ}.$module.shared.names.constants;

/**
* The container import MDB is used to receive asynchronous import commands for container data.
*/
@MessageDriven(mappedName = ${module.shared.names.constants}.JMS_IMPORT_QUEUE,
               activationConfig = {
                   @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = ${module.shared.names.constants}.JMS_IMPORT_QUEUE),
                   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                   @ActivationConfigProperty(propertyName = "messageSelector", propertyValue = "datatype = '" + ${module.shared.names.constants}.JMS_MESSAGE_SELECTOR_${item.underscoredName}_DATA + "'")
               })
@SuppressWarnings("unused") //'implements MessageListener' Workaround for WildFly bug
public class $className extends SingleTypeEventListenerBridgeByJms<String> implements MessageListener {

  @Inject  
  public void set${item.capName}Importer($item.xmlController.names.clazz $item.xmlController.names.instance) {
    super.setEventListener($item.xmlController.names.instance);
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.integ.dotsAsPath()}/ejb/${className}.java" %><% } %>'''

xml.backend.container.xmlConverter = '''<% def className = item.names.xmlConverter %>
$macros.header
package ${destModule.namespaces.core};

/**
* The $item.name converts string to container%>
*/
public interface $className extends ${item.names.xmlConverter}Base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %>'''

xml.backend.container.xmlConverterBase = '''<% def className = "${item.names.xmlConverter}Base" %>
$macros.header
package ${destModule.namespaces.core};

import com.siemens.ra.cg.pl.common.base.converter.MultiSourceConverter;
import ${item.nameFull()};

/**
* The $item.name converts string to container object %>
*/
public interface $className extends MultiSourceConverter<String, $item.names.clazz> {
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/${className}.java" %>'''

xml.backend.container.xmlConverterBaseImpl = '''<% def className = "${item.names.xmlConverter}BaseImpl" %>
$macros.header
package ${destModule.namespaces.core}.impl;

import javax.enterprise.inject.Alternative;
import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.util.XmlUtils;
import ${destModule.namespaces.core}.$item.names.xmlConverter;
import ${item.nameFull()};
import ${destModule.namespaces.core}.${module.names.xmlConverter};

/**
* The $item.name converts string to container object %>
*/
@Alternative
public abstract class $className<T> implements $item.names.xmlConverter {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());

  protected Class<T> xmlClass;
  protected ${module.names.xmlConverter} xmlConverter;

  //needed for CDI proxy
  protected $className() {
  }

  protected $className(Class<T> xmlClass) {
    this.xmlClass = xmlClass;
  }

  @Override
  public $item.names.clazz convert(String from) {
    log.info("convert(length={})", from.length());
    T xmlObject = XmlUtils.fromString(from, xmlClass, true);
    return convertXml(xmlObject);
  }

  @Override
  public $item.names.clazz convertFileFromClasspath(String fileInClasspath) {
    log.info("convertFileFromClasspath({})", fileInClasspath);
    T xmlObject = XmlUtils.fromPath(fileInClasspath, xmlClass, true);
    return convertXml(xmlObject);
  }

  protected abstract $item.names.clazz convertXml(T xmlObject);

  @Inject
  public void setXmlConverter(${module.names.xmlConverter} xmlConverter) {
    this.xmlConverter = xmlConverter;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %>'''

xml.backend.container.xmlConverterImpl = '''<% def className = "${item.names.xmlConverter}Impl" %>
$macros.header
package ${destModule.namespaces.core}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

import ${item.nameFull()};
import ${destModule.namespace}.${item.namespace}.impl.$item.names.impl;

/** The $item.name converts xml string to ${item.names.clazz} */
@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@ApplicationScoped
public class $className extends ${item.names.xmlConverter}BaseImpl<Object> {

  public $className() {
    super(Object.class);
    //TODO provide Root Element JaxbClass
  }

  @Override
  protected $item.names.clazz convertXml(Object xmlObject) {
    $item.names.clazz ret = new ${item.names.impl}();
    //TODO implement iterating over JAXB object and call proper converters of ${module.names.xmlConverter} xmlConverter
    return ret;
  }
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespaces.core.dotsAsPath()}/impl/${className}.java" %>'''

xml.backend.container.xmlController = '''<% def xmlController = item.xmlController; def className = xmlController.names.clazz %>
$macros.header
package ${destModule.namespace}.${xmlController.namespace};

/**
* The $item.name converts xml to container%>
*/
public interface $className extends $xmlController.names.base {
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${xmlController.namespace.dotsAsPath()}/${className}.java" %>'''

xml.backend.container.xmlControllerBase = '''<% def xmlController = item.xmlController; def className = xmlController.names.base %>
$macros.header
package ${destModule.namespace}.${xmlController.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.messaging.EventListener;

/** The $item.name converts xml to container object and imports it into system. */
public interface $className extends EventListener<String> {
  ${macros.apply(name: 'interfaceBody', item: xmlController)}
  @Transactional
  public void importData(String content);

  @Transactional
  public void importDataFromPath(String fileInClassPath);
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${xmlController.namespace.dotsAsPath()}/${className}.java" %>'''

xml.backend.container.xmlControllerBaseImpl = '''<% def xmlController = item.xmlController; def className = xmlController.names.baseImpl %>
$macros.header
package ${destModule.namespace}.${xmlController.namespace}.impl;

import javax.enterprise.inject.Alternative;
import javax.inject.Inject;

import org.slf4j.ext.XLogger;
import org.slf4j.ext.XLoggerFactory;

import com.siemens.ra.cg.pl.common.base.annotations.Transactional;
import com.siemens.ra.cg.pl.common.base.messaging.Event;
import ${item.nameFull()};
import ${item.controller.nameFull()};
import ${destModule.namespaces.core}.*;

@Alternative
public abstract class $className implements $xmlController.names.clazz {
  protected XLogger log = XLoggerFactory.getXLogger(getClass());
  ${macros.apply(name: 'refsMembers', item: xmlController)}
  protected $item.names.xmlConverter xmlContainerConverter;
  protected $item.controller.names.clazz containerController;
  ${macros.apply(name: 'implOperationsAndDelegates', override: true, item: xmlController)}
  @Override
  @Transactional
  public void importData(String content) {
    $item.names.clazz container = xmlContainerConverter.convert(content);
    importContainer(container);
  }

  @Override
  @Transactional
  public void importDataFromPath(String fileInClassPath) {
    $item.names.clazz container = xmlContainerConverter.convertFileFromClasspath(fileInClassPath);
    importContainer(container);
  }  

  @Override
  public Class<String> getEventObjectType() {
    return String.class;
  }

  @Override
  public void onEvent(Event<String> event) {
    importData(event.getFirstObject());
  }
  
  public void importContainer($item.names.clazz container) {
    containerController.importContainer(container);
  }
  ${macros.apply(name: 'implInjects', item: xmlController)}
  
  @Inject
  public void setXmlContainerContainer($item.names.xmlConverter xmlContainerConverter) {
    this.xmlContainerConverter = xmlContainerConverter;
  }

  @Inject
  public void setContainerContainer($item.controller.names.clazz containerController) {
    this.containerController = containerController;
  }
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${xmlController.namespace.dotsAsPath()}/impl/${className}.java" %>'''

xml.backend.container.xmlControllerImpl = '''<% def xmlController = item.xmlController; def className = xmlController.names.impl %>
$macros.header
package ${destModule.namespace}.${xmlController.namespace}.impl;

import static com.siemens.ra.cg.pl.common.base.integ.ExecutionType.*;
import static com.siemens.ra.cg.pl.common.base.integ.RuntimeType.*;

import javax.enterprise.context.ApplicationScoped;

import com.siemens.ra.cg.pl.common.base.cdi.env.Environment;
import com.siemens.ra.cg.pl.common.base.cdi.env.SupportsEnvironments;

@SupportsEnvironments({
    @Environment(runtimes = { SERVER }),
    @Environment(executions = { LOCAL, MEMORY }, runtimes = { CLIENT }) })
@ApplicationScoped
public class $className extends ${xmlController.names.baseImpl} {
  ${macros.apply(name: 'implOperations', item: xmlController)}
}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${xmlController.namespace.dotsAsPath()}/impl/${className}.java" %>'''

fx.ui.view.dialog = '''<% if (item.dialog) { def className = "${item.names.clazz}Fx" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import com.siemens.ra.cg.pl.common.base.annotations.View;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped;
import com.siemens.ra.cg.pl.common.base.cdi.root.RootScoped.RootType;

import ${item.presenter.nameFull()}.*;
import ${destModule.namespace}.${item.namespace}.*;

@RootScoped(RootType.NEW)
@View
public class $className extends ${item.names.clazz}FxBase {

}
<% ret.overwrite = false; ret.path = "${destModule.javaSrc}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''

fx.ui.view.dialogBase = '''<% if (item.dialog) { def className = "${item.names.clazz}FxBase" %>
$macros.header
package ${destModule.namespace}.${item.namespace};

import javax.inject.Inject;

import ${destModule.namespace}.${item.namespace}.*;

public class $className {
 
}
<% ret.path = "${destModule.javaSrcGen}/${destModule.namespace.dotsAsPath()}/${item.namespace.dotsAsPath()}/${className}.java" %><% } %>
'''


